# 인터럽트(Interrupt)
**인터럽트(Interrupt)** 란 프로그램이 실행되는 도중 어떤 중요 이벤트가 발생했을 때, CPU가 현재 수행 중인 작업을 잠시 중단하고 해당 이벤트 처리를 수행하도록 알리는 메커니즘이다. CPU는 프로세스를 수행 중이더라도 인터럽트가 발생하면 하던 일을 중단하고 다른 일을 처리해야 하는 것이다.

인터럽트는 크게 **하드웨어 인터럽트(외부 인터럽트)** 와 **소프트웨어 인터럽트/예외(내부 인터럽트)** 로 구분할 수 있다.

## 하드웨어 인터럽트(외부 인터럽트)

하드웨어 인터럽트는 CPU 외부의 장치(디스크, 키보드, 네트워크 장치 등)가 CPU에게 특정 이벤트 발생을 알리거나 CPU의 처리를 요청할 때 발생한다.

예를 들어 디스크에서 데이터를 읽는 작업을 수행할 때, 디스크 컨트롤러는 데이터를 로컬 버퍼에 적재한 뒤 완료 사실을 CPU에 알려야 한다. CPU가 이를 계속 확인하는 방식(폴링)은 비효율적이기 때문에, 작업이 완료되면 디스크 컨트롤러가 인터럽트 신호를 발생시켜 CPU에 알린다.

> 키보드, 마우스, 디스크 등 I/O 장치는 장치 제어를 담당하는 **컨트롤러**를 가지며, 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리를 **로컬 버퍼(Local Buffer)** 라고 한다.
> 

### 1. 타이머 인터럽트

운영체제는 하나의 프로세스가 CPU를 독점하지 않도록 일정 시간이 지나면 타이머 인터럽트를 발생시킨다. 이를 통해 실행 중인 프로세스(또는 스레드)를 전환할 수 있으며, 이 과정에서 컨텍스트 스위칭(Context Switching)이 발생한다.

### 2. I/O 인터럽트

키보드 입력, 마우스 클릭, 네트워크 패킷 수신과 같은 I/O 이벤트가 발생하면 인터럽트가 발생할 수 있다. 운영체제는 이를 처리하고, 앱이 필요로 하는 이벤트 형태로 전달한다.

### 3. 전원 이상 인터럽트

전원 공급 문제와 같은 긴급 상황이 발생하면 인터럽트를 통해 시스템이 안전하게 동작을 정리하거나 필요한 조치를 수행할 수 있다.

## 소프트웨어 인터럽트(내부 인터럽트)

소프트웨어 인터럽트는 CPU가 프로그램을 실행하는 도중 발생하는 이벤트로, 대표적으로 예외(Exception) 상황이나 시스템 콜(System Call) 수행 과정에서 발생한다.

- 예외(Exception): 0으로 나누기, 잘못된 메모리 접근 등
- 시스템 콜(System Call): 사용자 프로그램이 커널 기능을 사용하기 위해 trap/syscall 명령을 수행하는 것

## 인터럽트 과정

### 인터럽트 벡터 테이블(Interrupt Vector Table)

> 인터럽트 벡터 테이블이란, 인터럽트 종류(번호)별로 처리해야 할 인터럽트 핸들러(ISR)의 주소를 보관하는 테이블이다.
> 

운영체제 커널에는 인터럽트가 들어왔을 때 해야 할 일을 운영체제 개발자가 미리 구현해 커널 내에 포함시켜 둔다.

인터럽트가 발생하면 CPU는 커널로 제어권을 넘기고, 커널 영역 내에서 해당 인터럽트에 대한 처리 코드(ISR)를 실행한다.

이를 빠르게 처리하기 위해 운영체제는 **인터럽트 번호 → ISR 주소**를 매핑하는 자료구조인 **인터럽트 벡터 테이블**을 유지한다.

### 인터럽트 핸들러(Interrupt Handler)

> 인터럽트 발생 시 실제로 처리해야 할 코드를 인터럽트 처리 루틴(ISR: Interrupt Service Routine) 또는 인터럽트 핸들러(interrupt handler)라고 한다.
> 

ISR은 각 인터럽트 상황(타이머, I/O 등)에 대해 커널이 수행해야 할 동작을 정의해 둔 코드이다.

### 세부 과정

인터럽트는 하드웨어 장치가 발생시키기도 하고, 소프트웨어가 의도적으로 발생시키기도 한다.

CPU가 인터럽트 요청을 감지하면(보통 **명령 실행의 경계 지점**에서), 현재 실행 흐름을 잠시 중단하고 커널로 제어권을 넘겨 인터럽트를 처리한다.

프로세스 실행 중 디스크에서 데이터를 읽어야 하는 상황을 가정해보자.

- 프로세스는 디스크 I/O를 수행하기 위해 `system call`을 호출한다.
- CPU는 `syscall/trap`과 같은 명령을 수행하여 **커널 모드(kernel mode)** 로 전환한다.
- CPU는 현재까지 수행 중이던 실행 상태(PC, 레지스터, 메모리 주소, 하드웨어 상태 등)를 안전한 곳에 저장한다.
    - 세부적으로는 커널 스택 또는 OS가 관리하는 자료구조에 저장되며, 경우에 따라 PCB/TCB에 반영된다.
    
    > PCB(Process Control Block)
    커널의 데이터 영역에 존재하며 각각의 프로세스마다 고유의 PCB가 있다.
    인터럽트 발생 시 잠시 정지 해 놓은 프로세스의 어느 부분이 수행중이었는지를 저장한다.
    더 자세히는 PCB와 Context Switching 부분에서 다루겠다.
    > 
    - PC(Program Counter, IP)에 다음에 실행할 명령의 주소를 저장한다.
- CPU는 **인터럽트 벡터 테이블(Interrupt Vector Table)** 을 참조하여 해당 이벤트에 대응하는 **ISR(Interrupt Service Routine)** 주소를 얻는다.
- CPU는 ISR로 분기하여 인터럽트(또는 시스템 콜)를 처리한다.
- 처리가 끝나면 return-from-interrupt(예: `IRET`) 과정을 통해 저장해두었던 레지스터/PC 등의 상태를 복원한다.
- 이후 사용자 프로그램의 기존 실행 흐름으로 다시 복귀한다.

## 인터럽트와 특권 명령

### 명령어의 종류

CPU가 수행하는 명령에는 **일반 명령**과 **특권 명령**이 있다.

**일반 명령**은 메모리에서 자료를 읽어오고 CPU에서 계산을 수행하는 등, 대부분의 프로그램이 수행할 수 있는 명령이다.

**특권 명령**은 보안과 안정성을 위해 제한된 명령으로, 입출력 장치 접근, 타이머 제어 등 시스템 전체에 영향을 줄 수 있는 동작을 포함한다. 따라서 특권 명령은 **운영체제(커널)** 만 수행할 수 있다.

### kernel mode vs user mode

운영체제는 하드웨어적인 보안을 유지하기 위해 기본적으로 두 가지 실행 모드를 제공한다.

- **kernel mode**: 운영체제가 CPU의 제어권을 가지고 동작하는 모드로 **일반 명령**과 **특권 명령**을 모두 수행할 수 있다.
- **user mode**: 사용자 프로그램이 실행되는 모드로 **일반 명령**만 수행할 수 있다.

프로세스가 실행 중 디스크 I/O 같은 작업이 필요하다고 하자. 
사용자 프로그램은 user mode에서 특권 명령을 수행할 수 없으므로, 하드웨어 장치를 직접 제어할 수 없다.

이런 경우 사용자 프로그램은 운영체제에게 **시스템 콜(system call)**을 통해 작업을 요청한다. 시스템 콜은 사용자 모드에서 커널 모드로 진입하기 위한 **trap/syscall 명령(소프트웨어 인터럽트)** 을 실행하여 커널 코드 영역으로 제어 흐름을 이동시키는 방식으로 수행된다.

> 시스템 콜은 사용자 프로그램이 커널 기능(디스크 I/O, 네트워크, 프로세스 제어 등)을 사용할 수 있도록 제공되는 인터페이스이다.
> 

CPU가 system call(trap) 또는 하드웨어 인터럽트를 감지하면, 현재 실행 흐름을 중단하고 CPU의 제어권을 운영체제에게 양도한다. 이때 하드웨어적으로 **모드 비트(mode bit)가 변경되어 kernel mode로 전환**되며, 운영체제는 특권 명령을 수행할 수 있게 된다.

커널 모드와 유저모드에 관해 더 자세히는 앞서 설명한 글을 참고..

---

## iOS 개발자 알아야 할 인터럽트 관점

iOS 앱 개발자는 하드웨어 인터럽트나 인터럽트 핸들러(ISR)를 직접 다루지는 않는다. 인터럽트 처리는 커널(XNU)이 담당하며, 앱은 운영체제가 추상화해 제공하는 형태로 결과를 전달받는다.

예를 들어 터치 입력, 네트워크 패킷 수신, 파일 I/O 완료와 같은 이벤트는 내부적으로 인터럽트 기반으로 처리될 수 있으며, 그 결과가 앱에는 **이벤트(Event), 콜백(Callback), Notification, async/await** 형태로 전달된다.

또한 iOS에서는 **메인 스레드(Main Thread)** 가 UI 업데이트를 담당하므로, 네트워크 요청이나 디스크 접근처럼 시간이 오래 걸릴 수 있는 작업을 메인 스레드에서 처리하면 앱의 UI가 끊기거나 멈춘 것처럼 보일 수 있다. 따라서 개발자는 인터럽트 자체보다는, 인터럽트 처리 결과로 발생하는 비동기 이벤트를 적절히 처리하고 **UI 작업과 백그라운드 작업을 분리하는 방식(GCD, OperationQueue, Swift Concurrency)** 을 이해하는 것이 중요하다.
