# CPU 스케줄링(CPU Scheduling)
CPU 스케줄링(CPU Scheduling)이란 여러 프로세스(또는 스레드) 중 **어떤 작업에 CPU를 배정할지 결정하는 것**이다. 컴퓨터 시스템의 효율은 어떤 작업에 CPU를 먼저 배정하느냐에 따라 크게 달라지므로, CPU 스케줄링은 **시스템의 처리 효율성과 작업의 공정성**을 결정하는 중요한 기능이다.

운영체제의 스케줄링은 역할과 범위에 따라 **고수준(장기) 스케줄링, 중간 수준(중기) 스케줄링, 저수준(단기) 스케줄링** 으로 구분된다.

### 고수준 스케줄링 (High-level Scheduling, Long-term Scheduler)

고수준 스케줄링은 시스템에 들어오는 작업(job) 중에서 **어떤 작업을 받아들일지 또는 거부할지**를 결정한다. 이를 통해 시스템 내에서 동시에 실행 가능한 프로세스의 총 개수, 즉 **멀티프로그래밍 정도(degree of multiprogramming)** 를 조절한다.

### 중간 수준 스케줄링 (Mid-level Scheduling)

중간 수준 스케줄링은 고수준 스케줄링과 저수준 스케줄링 사이에서, 실행 중인 프로세스의 수를 조절하기 위한 스케줄링이다. 프로세스가 활성화된 이후에도 시스템에 과부하가 걸릴 수 있기 때문에, 일부 프로세스를 **중지(suspend)** 상태로 보내거나 다시 활성화(active)하여 **메모리에 올라간 활성 프로세스 수를 조정**한다. 이를 통해 시스템 과부하를 방지한다.

### 저수준 스케줄링 (Low-level Scheduling, Short-term Scheduler)

저수준 스케줄링은 준비 상태(ready)에 있는 프로세스(또는 스레드)들 중 **다음에 CPU에서 실행할 작업을 선택하는 스케줄링**이다. 즉, 실제로 CPU를 누구에게 배정할지를 결정하는 단계로, 일반적으로 우리가 말하는 **CPU 스케줄링은 이 단기(저수준) 스케줄링을 의미**한다.

## CPU 스케줄링의 목적

CPU 스케줄링은 준비 상태(Ready)에 있는 프로세스/스레드 중 누가 CPU를 사용할지 결정하는 과정이며, 스케줄링 정책은 다음 목적을 만족하도록 설계된다.

### 1. 공정성

모든 프로세스가 CPU 자원을 **편향 없이** 배정받도록 한다.

특정 프로세스만 계속 실행되거나, 반대로 특정 프로세스가 계속 밀리지 않도록 보장하는 것이 중요하다.

### 2. 효율성(Efficiency) / CPU 활용률 향상

CPU가 가능한 한 **유휴(idle) 상태가 되지 않도록** 한다.

특히 I/O 대기 중인 프로세스를 실행시키느라 CPU가 놀지 않도록, 실행 가능한 작업을 적절히 선택해 **CPU 이용률과 처리율을 높이는 것**이 핵심이다.

### 3. 반응성(Response Time)

사용자가 체감하는 시스템 성능을 위해, 입력(클릭/터치 등)에 대해 **빠르게 반응**할 수 있어야 한다.

따라서 인터랙티브 시스템(iOS/GUI 환경)에서는 처리량보다 **response time**이 더 중요한 목표가 되기도 한다.

### 4. 기아 상태 방지(Starvation Prevention) / 무한 연기 방지

우선순위가 낮거나 긴 작업이라도 **영원히 실행되지 않는 상황**(무한 연기)이 발생하면 안 된다.

이를 해결하기 위해 Aging(오래 기다리면 우선순위 상승) 같은 기법이 사용된다.

### 5. 우선순위 및 중요도 반영(Priority)

중요한 작업(예: UI 이벤트 처리, 시스템 서비스 등)은 더 빨리 실행되어야 한다.

따라서 스케줄링은 “무조건 공평”이 아니라, 상황에 따라 **우선순위 기반으로 차등 배정**이 가능해야 한다.

## 프로세스 상태

프로세스의 상태(process state)란, 프로세스가 생성되어 종료될 때까지 실행 흐름에 따라 계속 변화하는 상태를 의미한다. 운영체제는 프로세스를 관리하기 위해 상태를 구분하며, 상태 변화에 따라 스케줄링 및 자원 할당을 수행한다.

프로세스는 일반적으로 **5가지 상태(5-state process model)** 를 가진다.

- **생성(New)**: 프로세스가 생성되었지만 아직 실행 준비가 완료되지 않은 상태
- **준비(Ready)**: CPU를 할당받으면 즉시 실행 가능한 상태. 실행을 위해 CPU를 기다리는 상태
- **실행(Running)**: CPU를 할당받아 명령어를 수행 중인 상태
- **대기(Waiting / Blocked)**: I/O 요청 등 특정 이벤트가 발생하여 완료되기를 기다리는 상태. CPU를 할당받아도 바로 실행할 수 없으며, 이벤트가 완료되면 다시 Ready 상태로 전환된다.
- **종료(Terminated)**: 실행이 완료되어 종료된 상태. 운영체제가 자원을 회수하고 종료 상태를 정리한 후 프로세스는 시스템에서 제거된다.

## 프로세스 상태 전이

프로세스 상태 전이(Process State Transition)란 프로세스가 실행되는 동안 **Ready, Running, Waiting 등의 상태가 변화하는 것**을 의미한다. 운영체제는 프로세스의 상태를 관리하며, 상태 전이는 스케줄링 결정 또는 이벤트(인터럽트, I/O 요청/완료 등)에 의해 발생한다.

예를 들어 운영체제는 Ready 상태에 있는 여러 프로세스 중 하나를 선택해 CPU를 할당함으로써 **Running 상태로 전환(dispatch)** 시킬 수 있다. 반대로 타이머 인터럽트가 발생하거나 우선순위가 높은 작업이 들어오면, 현재 실행 중인 프로세스를 다시 Ready 상태로 돌려보내는 **선점(preemption)** 이 일어날 수 있다. 또한 실행 중인 프로세스가 I/O 작업을 요청하면 **Waiting 상태로 전환**되고, I/O가 완료되면 다시 Ready 상태로 돌아와 CPU 할당을 기다린다.

즉, 운영체제는 프로세스 상태 전이를 기반으로 CPU 자원을 배분하고, 프로세스 실행 흐름을 제어한다.

<img width="519" height="218" alt="Diagram of process state." src="https://github.com/user-attachments/assets/2288a854-3915-479e-8299-c8f0ee7a0d35" />

Diagram of process state.

- **Admitted (new → ready)**: 프로세스 생성이 완료되고 시스템이 이를 받아들여 **Ready Queue에 등록**됨
- **Scheduler Dispatch (ready → running)**: 준비 상태의 프로세스 중 하나가 CPU를 할당받아 실행 상태로 전환됨
- **Interrupt (running → ready)**: 타이머 인터럽트(time quantum 만료) 또는 더 높은 우선순위 프로세스 등장으로 인해, 실행 중이던 프로세스가 CPU를 반납하고 다시 준비 상태로 전환됨
- **I/O or event wait (running → waiting)**: 실행 중인 프로세스가 I/O 요청이나 특정 이벤트를 기다려야 하므로 대기 상태로 전환됨
- **I/O or event completion (waiting → ready)**: I/O 작업 또는 이벤트 처리가 완료되어 프로세스가 다시 실행 가능한 준비 상태로 전환됨

## 프로세스 상태의 다중 큐 (Multiple Queues)

운영체제는 프로세스를 관리하기 위해 PCB(Process Control Block)를 유지하며, 각 프로세스의 우선순위나 상태 정보 또한 PCB에 포함된다. CPU 스케줄링 과정에서 중요한 것은 “실행 가능한 프로세스 중 어떤 것을 선택할지”인데, 만약 시스템 내 모든 PCB를 매번 탐색해 다음 실행 대상을 결정한다면 비효율적이다.

따라서 운영체제는 프로세스들을 상태에 따라 여러 큐로 나누어 관리하며, 특히 Ready 상태 프로세스들을 효율적으로 선택하기 위해 **다중 큐(Multiple Queue)** 구조를 사용한다.

<img width="549" height="490" alt="The ready queue and various I/O device queues." src="https://github.com/user-attachments/assets/5ffee287-4c87-446d-93c9-46e3b41a33da" />

The ready queue and various I/O device queues.

### 준비 상태(Ready)의 다중 큐

Ready 상태의 프로세스들은 보통 Ready Queue에 모여 관리된다. 만약 우선순위 기반 스케줄링을 사용하는 경우, Ready Queue를 **우선순위별로 여러 개로 분리**해 관리할 수 있다.

예를 들어 우선순위가 높은 프로세스는 높은 우선순위 큐에 넣고, 낮은 프로세스는 낮은 큐에 넣으면 CPU 스케줄러는 매번 모든 프로세스를 탐색하지 않아도 **가장 높은 우선순위 큐에서 바로 실행 대상을 선택**할 수 있다.

또한 프로세스 우선순위를 부여하는 방식에는 다음이 있다.

- **고정 우선순위(Fixed Priority)**: 우선순위가 프로세스 수명 동안 변하지 않음
- **변동 우선순위(Dynamic Priority)**: 실행 과정에서 우선순위가 변할 수 있음 (예: aging, MLFQ 등)

### 대기 상태(Waiting)의 다중 큐

Waiting 상태(또는 blocked 상태)의 프로세스는 보통 I/O 완료 등의 이벤트를 기다리며, 디스크/네트워크 등 장치 종류에 따라 **여러 개의 device queue(I/O device queues)** 로 나뉘어 대기할 수 있다.

I/O 작업이 완료되면 해당 장치에서 인터럽트가 발생하고, 운영체제는 인터럽트 벡터(인터럽트 번호에 따른 ISR 주소 테이블)를 통해 적절한 인터럽트 처리 루틴을 수행한 뒤, 해당 프로세스를 다시 Ready 상태로 전환하여 Ready Queue로 이동시킨다.

대기 큐의 처리 순서는 기본적으로 FIFO 형태일 수 있지만, 디스크 스케줄링과 같이 장치의 효율을 높이기 위한 정책에 따라 I/O 요청 처리 순서가 달라질 수 있으며, 결과적으로 나중에 요청된 작업이 먼저 완료되는 경우도 발생할 수 있다.

## 스레드 스케줄링(Thread Scheduling)

프로세스 스케줄링과 마찬가지로 **스레드 스케줄링(Thread Scheduling)** 은 운영체제가 여러 스레드 중에서 CPU를 사용할 실행 단위를 선택하고 CPU를 할당하는 과정을 의미한다. 현대 운영체제에서는 보통 프로세스 자체보다 **커널 스레드(kernel thread)** 가 실제 스케줄링 단위가 된다.

운영체제는 스레드의 우선순위(priority), 실행 시간(time quantum), I/O 요청 여부 등을 고려해 다음에 실행할 스레드를 선택하며, Round Robin, Priority Scheduling, Multilevel Queue(또는 MLFQ) 등의 방식이 사용된다.

다만 스레드는 같은 프로세스 내부에서 코드/data/heap과 같은 자원을 공유하기 때문에, 프로세스 간 스케줄링보다 **동기화(synchronization)** 및 **경쟁 상태(race condition)** 문제가 더 자주 발생하며 이를 고려한 설계가 필요하다.

> iOS에서는 개발자가 직접 스레드 스케줄링을 구현하기보다는, GCD/OperationQueue/Swift Concurrency에 작업을 위임하고 QoS(우선순위)를 조절하는 방식으로 스케줄링에 간접적으로 참여한다.
> 

### 스레드 상태(Thread State)

스레드의 상태는 운영체제나 구현 방식에 따라 다소 차이가 있지만, 일반적으로 다음과 같은 상태로 구분할 수 있다.

- **New**: 스레드가 생성된 상태 (아직 실행되지 않음)
- **Ready (Runnable)**: CPU를 할당받으면 즉시 실행 가능한 상태
- **Running**: CPU를 할당받아 실제로 실행 중인 상태
- **Blocked / Waiting**: I/O 완료, lock 획득, 이벤트 발생 등을 기다리며 실행할 수 없는 상태
- **Terminated**: 실행을 완료하고 종료된 상태

## 프로세스 우선순위(Priority)

프로세스(또는 스레드)의 우선순위가 높다는 것은 운영체제가 해당 작업을 더 자주, 더 빨리 실행하도록 CPU 할당에서 우선권을 준다는 의미이다. 운영체제는 시스템 효율성과 사용자 체감 성능을 높이기 위해 프로세스의 성격에 따라 우선순위를 다르게 부여한다.

### 1. 시스템 작업(커널/시스템 프로세스)

운영체제는 하드웨어 제어, 메모리 관리, 네트워크 처리 등 시스템 안정성과 직결되는 작업을 수행한다. 이러한 커널/시스템 작업은 사용자 앱보다 중요한 경우가 많으므로 일반적으로 더 높은 우선순위를 갖는다.

### 2. CPU 집중 작업 vs I/O 집중 작업

프로세스는 CPU 연산 중심(CPU-bound) 또는 입출력 중심(I/O-bound)으로 구분할 수 있다.

I/O-bound 작업은 CPU를 오래 점유하지 않고 빠르게 I/O를 요청한 뒤 waiting 상태로 전환되기 때문에, 먼저 실행되면 전체 시스템 관점에서 CPU 유휴 시간을 줄이고 효율을 높이는 효과가 있다. 따라서 운영체제는 I/O-bound 작업을 상대적으로 우선 처리하여 시스템 처리량과 응답성을 향상시킨다.

### 3. 전면 작업(Foreground) vs 후면 작업(Background)

전면 작업은 사용자 입력과 직접 상호작용하는 프로세스로, 빠른 응답이 중요하다. 반면 후면 작업은 사용자와 상호작용하지 않는 배치성 작업이므로 즉각적인 응답이 덜 중요하다. 따라서 운영체제는 전면 작업에 더 높은 우선순위를 부여하는 경우가 많다.

## 스케줄링 알고리즘

스케줄링 알고리즘은 여러 종류가 있으며, 어떤 알고리즘이 더 좋은지는 “무엇을 우선 가치로 두느냐”에 따라 달라진다. 알고리즘 성능 비교에는 **평균 대기 시간(Waiting Time)**, **반환 시간(Turnaround Time)** 등이 자주 사용되며, 인터랙티브 시스템에서는 **응답 시간(Response Time)** 이 특히 중요한 기준이 된다.

- **처리량(Throughput)**: 단위 시간당 처리 가능한 작업 수
- **반응 시간(Response Time)**: 요청 후 첫 응답까지 걸리는 시간
- **대기 시간(Waiting Time)**: Ready Queue에서 CPU 할당을 기다리는 시간
- **반환 시간(Turnaround Time)**: 작업 제출부터 완료까지 걸리는 전체 시간

상황에 따라 어떤 기준이 더 중요한지가 달라지므로, 시스템 목적에 맞는 알고리즘을 선택하는 것이 중요하다.

## 선점형 스케줄링과 비선점형 스케줄링

운영체제에서 선점(preemption)은 **실행 중인 작업으로부터 CPU를 “빼앗을 수 있는지”** 여부를 의미한다. 따라서 **선점형 스케줄링(Preemptive Scheduling)** 은 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 회수하여 다른 프로세스에게 할당할 수 있는 방식이다. 반대로 **비선점형 스케줄링(Non-preemptive Scheduling)** 은 한 프로세스가 CPU를 점유하면 **자발적으로 CPU를 반납할 때까지** 다른 프로세스가 이를 빼앗을 수 없는 방식이다.

선점형 스케줄링은 주로 **타이머 인터럽트(time quantum 만료)** 또는 더 높은 우선순위 프로세스의 등장과 같은 상황에서 발생하며, 응답성을 높여 시분할 시스템에 적합하다. 반면 비선점형 스케줄링은 프로세스가 종료되거나 I/O 요청으로 대기 상태에 들어가기 전까지 CPU를 점유하므로 구현은 단순하지만 응답성이 떨어질 수 있어 과거의 일괄 처리(batch) 시스템에서 주로 사용되었다.


## 비선점형 스케줄링

### FCFS 스케줄링 (First Come First Served)

FCFS는 준비 큐(Ready Queue)에 먼저 도착한 프로세스부터 CPU를 할당하는 **비선점형** 스케줄링 방식이며, 선입선출(FIFO) 방식이라고도 한다. 구현이 단순하며 초기의 일괄 처리(batch) 시스템에서 사용되었다.

하지만 FCFS는 **우선순위를 고려하지 않기 때문에**, CPU 사용 시간이 긴 프로세스가 먼저 실행되면 이후 프로세스들이 오래 기다리게 된다. 이로 인해 CPU-bound 프로세스 뒤에 I/O-bound 프로세스들이 줄줄이 대기하는 **콘보이 효과(convoy effect)** 가 발생할 수 있고, 전체 시스템 효율이 저하될 수 있다.

이러한 단점을 개선하기 위해 CPU 사용 시간이 짧은 작업을 우선 실행하는 SJF 스케줄링이 등장한다.

### SJF 스케줄링 (Shortest Job First)

SJF는 준비 큐에 있는 프로세스 중 **실행 시간이 가장 짧은 작업부터** CPU를 할당하는 **비선점형** 스케줄링 방식이며, 최단 작업 우선 스케줄링이라고도 한다. 짧은 작업을 먼저 처리하기 때문에 평균 대기 시간을 줄이고 시스템 효율을 높일 수 있다.

다만 SJF는 현실적인 제약이 있다. 현대 운영체제에서 프로세스의 실제 실행 시간(CPU burst length)을 정확히 예측하기 어렵기 때문에, 이상적인 방식처럼 적용하기가 힘들다. 또한 긴 작업은 계속 뒤로 밀릴 수 있어 **기아 상태(starvation)** 가 발생할 수 있다.

이때 starvation을 완화하기 위해 **에이징(Aging)** 기법을 사용할 수 있다. Aging은 프로세스가 오래 대기할수록 우선순위를 점진적으로 높여, 일정 시간 이상 기다린 프로세스가 결국 실행될 수 있도록 만드는 방식이다.

> 참고로 SJF는 선점형 방식으로 확장하면 SRTF(Shortest Remaining Time First)가 된다.
> 

### HRN 스케줄링 (Highest Response Ratio Next)

HRN은 SJF에서 발생할 수 있는 starvation 문제를 완화하기 위해 등장한 **비선점형** 알고리즘이며, 최고 응답률 우선 스케줄링이라고도 한다.

SJF는 “실행 시간”만 고려하지만, HRN은 “대기 시간 + 실행 시간”을 함께 고려하여 긴 작업이 무한히 밀리지 않도록 설계되었다. HRN의 우선순위(응답률)는 다음과 같이 계산된다.

> Response Ratio = (Waiting Time + Service Time) / Service Time
> 
> 
> = **1 + (Waiting Time / Service Time)**
> 

운영체제는 응답률이 가장 높은 프로세스에 CPU를 할당한다.

HRN은 SJF보다 starvation을 완화할 수 있지만, 여전히 실행 시간(Service Time)을 추정해야 한다는 한계가 있으며, 현대 운영체제에서 직접적으로 널리 사용되지는 않는다.

 

> 비선점형 스케줄링은 구현이 단순하지만 응답성이 떨어질 수 있어, 현대의 인터랙티브 환경에서는 선점형 방식이 더 많이 사용된다.
> 

## 섬점형 스케줄링

### 라운드 로빈 스케줄링(Round Robin, RR)

라운드 로빈 스케줄링은 한 프로세스가 할당받은 시간(타임 슬라이스, time quantum) 동안 CPU를 사용하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 이동해 다시 자기 차례를 기다리는 방식이다. **선점형 알고리즘 중 가장 단순하고 대표적인 방식**이며, 여러 프로세스를 공평하게 순환하며 실행한다.

FCFS에 비해 **콘보이 효과(convoy effect)가 줄어들고**, 특히 사용자와 상호작용이 많은 시스템에서 **응답성을 보장**하는 데 유리하다.

다만 타임 슬라이스가 너무 작으면 컨텍스트 스위칭이 빈번하게 발생해 오버헤드가 증가하고, 평균 대기 시간 관점에서 비효율적일 수 있다.

### SRTF 스케줄링(Shortest Remaining Time First)

SRTF는 **SJF 스케줄링의 선점형 버전**으로, 준비 큐에 있는 프로세스 중 **남은 실행 시간이 가장 짧은 프로세스**에게 CPU를 할당한다.

이때 이미 실행 중인 프로세스가 있더라도, 더 짧은 남은 실행 시간을 가진 프로세스가 준비 큐에 들어오면 운영체제는 현재 실행 중이던 프로세스를 선점(preemption)하고 새로운 프로세스를 실행한다.

SRTF는 평균 대기 시간을 줄이는 데 유리하지만, 프로세스의 CPU burst 시간을 예측하기 어렵고 starvation(기아 상태) 문제가 발생할 수 있어 실제 시스템에서는 적용이 쉽지 않다.

### 다단계 큐 스케줄링(Multi-Level Queue, MLQ)

다단계 큐 스케줄링은 우선순위에 따라 준비 큐를 여러 개로 분리하는 방식이다. 프로세스는 운영체제로부터 부여받은 고정 우선순위에 따라 해당 큐에 삽입되며, 스케줄러는 항상 **상위 우선순위 큐의 프로세스를 먼저 실행**하며 각 큐는 라운드 로빈 방식으로 운영된다.

<img width="549" height="356" alt="Multilevel queue scheduling" src="https://github.com/user-attachments/assets/59f8d772-4db2-4690-b4ff-8c3f5270a7c7" />


상위 큐가 비어 있을 때만 하위 큐가 실행되며, 하위 큐에서 실행 중이던 프로세스라도 상위 큐에 새로운 프로세스가 들어오면 선점될 수 있다. 이로 인해 우선순위가 낮은 프로세스는 실행이 계속 밀리는 문제가 생길 수 있다.

### 다단계 피드백 큐 스케줄링(Multi-Level Feedback Queue, MLFQ)

<img width="397" height="253" alt="Multilevel feedback queues" src="https://github.com/user-attachments/assets/fbc7368b-44b4-4584-94d1-fb72acb16247" />

다단계 피드백 큐는 다단계 큐의 단점을 보완한 방식으로, 프로세스가 CPU를 사용한 뒤 실행 특성에 따라 **큐 간 이동이 가능한 스케줄링 기법**이다.

프로세스가 CPU를 할당받아 타임 슬라이스를 모두 사용하면, 해당 프로세스는 한 단계 낮은 우선순위 큐로 이동한다. 즉 CPU를 오래 사용하는 CPU-bound 작업은 점점 하위 큐로 내려가게 된다.

반대로 I/O 중심(I/O-bound) 작업은 CPU를 짧게 쓰고 waiting 상태로 자주 빠지므로 상대적으로 상위 큐에 머무는 경향이 있어 응답성이 좋아진다.

또한 우선순위가 낮은 큐일수록 타임 슬라이스가 길어지는 경우가 많으며, 최하위 큐는 FCFS처럼 동작하기도 한다.

MLFQ는 변동 우선순위(dynamic priority)를 사용하며, 오늘날 운영체제에서 널리 사용되는 대표적인 CPU 스케줄링 방식 중 하나이다.

## Priority Scheduling (비선점/선점 모두 가능)

Priority Scheduling은 프로세스(또는 스레드)에 **우선순위(priority)** 를 부여하고, Ready Queue에서 우선순위가 높은 작업부터 CPU를 할당하는 방식이다. 우선순위는 프로세스의 중요도, 사용자의 체감 성능, CPU/I/O 특성 등을 기준으로 **정적(static)** 또는 **동적(dynamic)** 으로 부여될 수 있다.

Priority Scheduling은 구현 방식에 따라 다음 두 형태로 나뉜다.

- **비선점형 Priority**: CPU를 할당받은 프로세스는 종료되거나 대기 상태에 들어갈 때까지 실행된다.
- **선점형 Priority**: 실행 중인 프로세스보다 더 높은 우선순위 프로세스가 Ready Queue에 들어오면, 운영체제가 CPU를 회수하여 높은 우선순위 프로세스를 즉시 실행할 수 있다.

다만 Priority Scheduling은 우선순위가 낮은 프로세스가 계속 뒤로 밀려 **무한정 실행되지 못하는 기아 상태(Starvation)** 가 발생할 수 있다. 이를 완화하기 위해 **Aging** 기법을 적용할 수 있는데, 이는 오래 기다린 프로세스의 우선순위를 점진적으로 상승시켜 결국 실행될 수 있도록 보장하는 방식이다.

---

## iOS 관점에서 살펴 볼 이야기

### Priority Inversion & Priority Inheritance

Priority Scheduling에서는 높은 우선순위 작업이 먼저 실행되어야 하지만, 공유 자원(락)을 사용하는 멀티 스레드 환경에서는 **우선순위 역전(Priority Inversion)** 문제가 발생할 수 있다.

이는 낮은 우선순위 스레드가 락(lock)을 점유하고 있는 동안, 높은 우선순위 스레드가 해당 락을 기다리며 blocked 상태가 되고, 그 사이 중간 우선순위 스레드가 CPU를 계속 점유하면서 낮은 우선순위 스레드가 실행되지 못해 락 해제가 지연되는 현상이다. 결과적으로 높은 우선순위 작업이 낮은 우선순위 작업에 의해 간접적으로 지연되는 “역전”이 발생한다.

이를 해결하기 위해 운영체제는 **우선순위 상속(Priority Inheritance)** 기법을 사용할 수 있다. 높은 우선순위 스레드가 락을 기다리고 있다면, 운영체제는 락을 점유한 낮은 우선순위 스레드의 우선순위를 일시적으로 높여 빠르게 실행되도록 하며, 락을 해제한 후에는 원래 우선순위로 되돌린다. 이를 통해 우선순위 역전을 완화하고 시스템의 응답성을 보장할 수 있다.

### iOS에서의 우선순위 역전

iOS 앱 개발에서 가장 중요한 실행 흐름은 **메인 스레드(Main Thread)** 이다. UI 업데이트, 사용자 입력 이벤트 처리 등 사용자 경험과 직결되는 작업이 모두 메인 스레드에서 수행되기 때문에, 메인 스레드는 가능한 한 block되지 않아야 한다.

하지만 멀티 스레드 환경에서 **메인 스레드가 공유 자원(락)을 기다리는 상황**이 발생하면, 짧은 시간이라도 UI가 멈추거나 frame drop이 발생할 수 있다. 즉 우선순위 역전 문제는 iOS 관점에서는 단순한 스케줄링 이슈를 넘어 **“UI 멈춤/버벅임”** 으로 직결될 수 있다.

### 우선순위(QoS) + 동기화 작업

iOS는 GCD 또는 Swift Concurrency를 통해 작업을 분배하며, 각 작업에는 QoS(Quality of Service) 우선순위가 적용된다.

- userInteractive (가장 높음)
- userInitiated
- utility
- background (가장 낮음)

이때 낮은 QoS 작업이 락을 점유하고 있고, 높은 QoS 작업이 해당 락을 기다리는 구조가 만들어지면, **높은 우선순위 작업이 간접적으로 지연**되며 우선순위 역전 문제처럼 보일 수 있다. 특히 메인 스레드 수준의 QoS 작업(userInteractive)이 영향을 받으면 사용자 경험이 즉시 악화된다.

### Swift Concurrency에서도 같은 문제 가능

Swift Concurrency는 actor 기반으로 데이터 레이스를 방지하는 데 큰 도움을 주지만, 다음과 같은 구조에서는 여전히 “대기”가 길어져 UI 지연이 발생할 수 있다.

- `@MainActor`에서 실행되는 코드가 다른 actor(또는 shared resource)의 작업 완료를 기다리는 구조
- Task들이 lock 또는 serial queue 같은 공유 자원을 경쟁하는 구조
- 높은 QoS Task가 낮은 QoS Task가 점유한 리소스를 기다리는 구조

즉, Swift Concurrency를 사용하더라도 우선순위/동기화 설계가 잘못되면 UI 레이턴시가 발생할 수 있다.

### 예방/개선 포인트

- 메인 스레드에서 lock 기반 공유 자원을 오래 잡지 않기
- critical section 최소화 (락 점유 시간을 짧게)
- 공유 자원 접근을 줄이고 immutable 설계 활용
- QoS가 다른 작업이 같은 lock을 공유하지 않도록 구조 분리
- 가능한 경우 async 기반 설계(블로킹 최소화)
