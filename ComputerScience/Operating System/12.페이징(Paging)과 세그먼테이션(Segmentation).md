# 페이징(Paging)과 세그먼테이션(Segmentation)
운영체제를 공부하다 보면 “프로세스 주소 공간”이라는 개념을 만나게 된다.

프로세스는 자신만의 독립적인 메모리 공간을 가지는 것처럼 보이지만, 실제로는 **가상 메모리(Virtual Memory)** 위에서 동작한다. 이 가상 메모리를 효율적이고 안전하게 관리하기 위해 등장한 대표적인 기법이 **페이징(Paging)** 과 **세그먼테이션(Segmentation)** 이다.

## **가상 메모리(Virtual Memory)**란?

우리가 사용하는 프로그램은 생각보다 훨씬 많은 메모리를 필요로 한다. 하지만 물리적인 RAM은 한정되어 있는데, 이때 운영체제가 사용하는 핵심 기술이 **가상 메모리(Virtual Memory)**이다.

가상 메모리는 **실제 물리 메모리보다 큰 주소 공간을 제공하는 메모리 관리 기법**이다. 프로그램이 실행될 때 프로세스 전체를 메모리에 올리지 않더라도 실행이 가능하다는 점에서 착안하여 고안되었다.

프로그램 입장에서는 마치 매우 큰 메모리를 독점적으로 사용하는 것처럼 동작하지만, 실제로는 **일부 페이지만 물리 메모리에 올라가 있고 나머지는 보조 기억장치(디스크)**에 저장되어 있다.

프로그램, 즉 애플리케이션이 실행될 때 필요한 부분만 메모리에 적재되며, 나머지는 디스크에 남아 있다. 이때 디스크는 RAM의 **보조 기억장치(backing store)**처럼 동작한다. 결과적으로 운영체제는 **빠르지만 작은 기억장치(RAM)**와 **느리지만 큰 기억장치(디스크)**를 결합하여, 하나의 **크고 빠른 메모리처럼 보이게 만드는 효과**를 만든다.

### 가상 메모리가 필요한 이유

- 물리 메모리가 제한되어 있어도 여러 프로그램을 동시에 실행할 수 있다.
- 실제 RAM 크기보다 훨씬 큰 주소 공간을 프로세스에 제공할 수 있다.
- 프로세스마다 독립적인 주소 공간을 제공하여 메모리 보호가 가능하다.
- 메모리 사용 효율이 높아지고 시스템 전체 처리량이 증가한다.

### MMU(Memory Management Unit)

가상 메모리를 구현하기 위해서는 CPU와 함께 동작하는 특수 하드웨어가 필요한데, 이것이 **MMU(Memory Management Unit)**이다.

MMU의 핵심 역할은 다음과 같다.

- 가상 주소(Virtual Address)를 물리 주소(Physical Address)로 변환
- 프로세스 간 메모리 보호 수행 (접근 권한 검사)

CPU가 메모리에 접근하기 전에, MMU는 항상 주소 변환을 수행한다. 하지만 매번 주소를 변환하면 성능 저하가 발생할 수 있기 때문에, MMU는 메모리를 **페이지(Page)** 단위로 나누어 관리하고, 페이지 테이블을 기반으로 주소 변환을 수행한다.

이때 가상 주소 → 물리 주소 변환 정보를 저장하고 관리하는 과정이 가상 메모리 구현의 핵심이다.

### 요구 페이징(Demand Paging)

가상 메모리 시스템에서는 프로세스 실행 시 모든 페이지를 한 번에 메모리에 적재하지 않는다. 대신 **CPU가 실제로 접근하는 페이지에 대해서만 메모리에 적재**하는 방식을 사용하는데, 이를 **요구 페이징(Demand Paging)**이라고 한다.

### 페이지 폴트(Page Fault)

요구 페이징 환경에서는 CPU가 접근하려는 페이지가 물리 메모리에 존재하지 않는 상황이 발생할 수 있다. 이때 발생하는 인터럽트를 **페이지 폴트(Page Fault)**라고 한다.

페이지 폴트가 발생하면 운영체제는 다음과 같은 과정을 수행한다.

1. 페이지 폴트 인터럽트 발생
2. 해당 페이지가 디스크(backing store)에 존재하는지 확인
3. 빈 프레임을 확보하거나, 필요 시 기존 페이지를 교체
4. 디스크에서 페이지를 메모리로 로드
5. 페이지 테이블 갱신
6. 중단되었던 명령어를 다시 실행

이 과정을 통해 프로그램은 **페이지 폴트가 발생했다는 사실을 인지하지 못한 채 계속 실행**될 수 있다.

하지만 페이지 폴트는 디스크 I/O를 동반하므로 비용이 매우 크다. 따라서 페이지 폴트가 과도하게 발생하면 시스템 성능이 급격히 저하된다.

이 문제를 완화하기 위해 운영체제는 **어떤 페이지를 교체할 것인지 결정하는 정책**, 즉 **페이지 교체 알고리즘**을 사용한다. 이에 대한 내용은 다음 글에서 자세히 다룰 예정이다.

# 메모리 관리 기법

가상 메모리 외에도 프로그램을 어떻게 메모리에 적재할 것인지는 여러 방법들이 존재한다.

## 연속 메모리 관리(Contiguous Memory Allocation)

프로그램 전체를 하나의 연속된 메모리 공간에 적재하는 방식이다.

- **고정 분할 기법(Fixed Partitioning)**
    - 주 기억 장치를 고정된 크기의 파티션으로 나누는 방식이다.
    - 프로세스 크기와 파티션 크기가 맞지 않을 경우 내부 단편화가 발생할 수 있다.
- **동적 분할 기법(Dynamic Partitioning)**
    - 프로세스의 크기에 맞게 파티션을 동적으로 생성하여 메모리에 적재하는 방식이다.
    - 메모리 할당과 해제가 반복되면서 외부 단편화가 발생할 수 있다.

연속 메모리 관리 방식에서는 단편화 현상이 발생할 수 있다. 단편화란 메모리 공간이 비효율적으로 사용되어 실제로 사용 가능한 메모리가 줄어드는 현상이다.

### 내부 단편화(Internal Fragmentation)

프로세스가 할당된 메모리 공간 내부에서 실제로 사용되지 않고 남는 공간이 발생하는 현상이다.

즉 프로세스가 요청한 크기보다 더 큰 메모리 블록이 할당되어, **할당된 메모리 블록 내부에 사용되지 않고 남는 공간을 의미한다.**

### 외부 단편화(External Fragmentation)

메모리 공간이 여러 작은 조각으로 나뉘어 **총 메모리는 충분하지만 연속된 공간이 없어 할당할 수 없는 상태를 말한다.**

즉, 메모리 할당 및 해제 작업의 반복으로 작은 메모리가 중간 중간 존재하게 되며, 이렇게 사용하지 않는 메모리가 존재하게 되면 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황이 생기게 된다.

외부 단편화를 해결하기 위해 압축(compaction)을 사용할 수 있으나, 비용이 크기 때문에 실제 시스템에서는 잘 사용되지 않는다.

---

## 불연속 메모리 관리(Non-contiguous Memory Allocation)

불연속 메모리 관리는 프로그램의 일부가 **서로 다른 주소 공간에 할당**될 수 있는 메모리 관리 기법이다. 연속 메모리 관리 방식에서 발생하는 단편화 문제를 해결하기 위해 제시된 방법이다.

대표적인 불연속 메모리 관리 기법으로 **페이징(Paging)** 과 **세그먼테이션(Segmentation)** 이 있다.

> 페이징은 고정 크기 단위로 메모리를 분할하여 외부 단편화를 제거하지만,
> 
> 
> 세그먼테이션은 논리적 단위로 분할하여 **내부 단편화를 제거**하는 대신
> 
> **외부 단편화가 발생할 수 있다**는 차이가 있다.
> 

### 주요 용어 정리

- **페이지(Page)**
    
    고정 크기의 프로세스 조각
    
- **프레임(Frame)**
    
    페이지와 동일한 크기를 가지는 물리 메모리 조각
    
- **세그먼트(Segment)**
    
    코드, 데이터, 스택 등 의미를 기준으로 나뉜 **가변 크기의 논리적 메모리 블록**
    
- 페이징(Paging)
    - **고정 크기 분할**
- 세그먼테이션(Segmentation)
    - **가변 크기 분할**

---

### 페이징(Paging)

페이징은 프로세스를 **일정한 크기의 페이지 단위로 분할**하여 메모리에 적재하는 방식이다.

이 방식은 하나의 프로세스가 사용하는 메모리 공간이 **물리 메모리 상에서 연속될 필요가 없도록** 만든다.

물리 메모리는 고정 크기의 프레임으로, 가상 메모리는 동일한 크기의 페이지로 분리된다. 각 페이지는 순서와 상관없이 물리 메모리의 프레임에 매핑되어 저장된다.

<img width="450" height="390" alt="Paging model of logical and physical memory." src="https://github.com/user-attachments/assets/87f822af-fed5-4216-a233-efdd0daebf07" />


### 페이징 테이블(Paging Table)

모든 프로세스는 자신의 페이지 정보를 관리하는 **페이지 테이블**을 가진다.

페이지 테이블에는 다음 정보가 포함된다.

- 가상 메모리의 페이지 번호
- 해당 페이지가 적재된 물리 메모리 프레임 번호

이를 통해 하나의 프로세스를 나눈 가상 메모리 페이지들이 각각 실제 메인 메모리의 어디 프레임에 적재되어 있는지 알아낼 수 있다.

가상 주소는 `<page number, offset>`과 같은 형태로 구성되는데 메모리 관리 장치(MMU)가 가상 주소를 물리 주소로 변환할 때, 이를 이용해 물리 주소로 변환해 주는 것이다.

### 페이징의 장단점

**장점**

- 논리 메모리가 물리 메모리에 연속적으로 저장될 필요가 없음
- 물리 메모리의 남는 프레임에 페이지를 자유롭게 배치 가능
- **외부 단편화가 발생하지 않음**

**단점**

- 페이지 크기보다 작은 데이터가 할당될 경우 **내부 단편화 발생**
- 페이지 크기를 작게 하면 내부 단편화는 줄어들지만, 페이지 수 증가로 인해 **페이지 테이블 크기 증가** 및 **주소 변환 비용(TLB miss 가능성)** 이 증가할 수 있음

> **TLB(Translation Lookaside Buffer, 페이지 정보 캐시)**는 가상 메모리 주소를 물리적 주소로 변환하는 속도를 높이기 위해 사용하는 캐시이다.
> 

---

### 세그먼테이션(Segmentation)

세그먼테이션은 가상 메모리를 **서로 크기가 다른 논리적 단위(세그먼트)** 로 분할하는 방식이다.

프로세스를 물리적 단위인 페이지가 아니라, **논리적 의미를 기준으로 한 세그먼트 단위**로 나누어 메모리에 적재한다.

세그먼트는 코드, 데이터, 스택 등 의미가 서로 다르기 때문에 크기가 동일하지 않다.


<img width="487" height="434" alt="Paging model of logical and physical memory." src="https://github.com/user-attachments/assets/91cf1b80-dc0c-44e1-9ba8-61ca2f9aacdf" />


### 세그먼트 테이블**(Segment Table)**

세그먼테이션 역시 주소 변환을 위해 매핑 테이블을 사용하며, 논리 주소는 `<segment number, offset>`과 같은 형태를 가진다.

세그먼트 테이블에는 다음 정보가 저장된다.

- **Base** : 세그먼트의 시작 물리 주소
- **Limit** : 세그먼트의 길이

이를 통해 주소 변환과 함께 **메모리 보호 및 접근 권한 검사**가 가능하다.

### 세그먼테이션의 장단점

**장점**

- **내부 단편화가 발생하지 않음**
- 논리적 단위 기반이므로 **보호 및 공유에 유리**
- 프로그램의 중요한 부분과 덜 중요한 부분을 분리하여 관리 가능
- 동일한 코드 영역을 여러 프로세스가 공유 가능

**단점**

- 가변 크기 할당으로 인해 **외부 단편화 발생 가능**
- 동적 할당 및 해제로 인한 **관리 오버헤드**가 존재

---

## 페이징과 세그먼테이션 정리

### 단순 페이징 (Simple Paging)

- 프로세스는 동일한 크기의 페이지로 분할됨
- 외부 단편화 없음
- 내부 단편화 발생 가능

### 단순 세그먼테이션 (Simple Segmentation)

- 프로세스는 여러 개의 세그먼트로 분할됨
- 내부 단편화 없음
- 외부 단편화 발생 가능
- 논리적 구조 기반 관리로 메모리 효율성 향상

### 가상 메모리 페이징 (Virtual Memory Paging)

- 프로세스의 모든 페이지를 한 번에 적재할 필요 없음
- 필요한 페이지를 나중에 자동으로 로드 (요구 페이징)
- 외부 단편화 없음
- 복잡한 메모리 관리로 인한 오버헤드 발생 가능

### 가상 메모리 세그먼테이션 (Virtual Memory Segmentation)

- 필요하지 않은 세그먼트는 로드되지 않음
- 필요한 세그먼트만 동적으로 로드
- 내부 단편화 없음
- 복잡한 관리 구조로 인한 오버헤드 발생 가능

---

# 정리 및 iOS 개발자로서 알면 좋은 것들

페이징과 세그먼테이션은 각각 단편화 문제를 해결하기 위해 제안된 기법이지만, 서로 다른 장단점을 가진다.

이러한 메모리 관리 기법 위에서 **요구 페이징**과 **페이지 교체 알고리즘**이 결합되어 현대 운영체제의 가상 메모리 시스템이 완성된다.

다음 글에서는 **페이지 폴트 발생 시 어떤 페이지를 교체할 것인지 결정하는 페이지 교체 알고리즘**에 대해 정리해볼 예정이다.

## **iOS 개발자 관점에서 알아두면 좋은 가상 메모리 이야기**

iOS 역시 macOS와 동일하게 **가상 메모리(Virtual Memory)** 를 기반으로 동작한다.

하지만 서버나 데스크톱 OS와는 다르게, **모바일 환경에 최적화된 방식**으로 동작한다는 점이 중요하다.

특히 **페이지 폴트(Page Fault)** 가 발생했을 때의 동작은 iOS 개발자가 성능 이슈를 이해하는 데 중요한 힌트를 준다.

### iOS에서의 페이지 폴트는 느려지기 보다 앱 종료를 선택

일반적인 데스크톱 OS에서는 페이지 폴트가 발생하면 디스크(스왑 영역)에서 페이지를 불러와 메모리에 적재한다.

하지만 **iOS는 기본적으로 스왑(Swap)을 사용하지 않는다.**

> 즉, iOS는
> 
> 
> 디스크에서 페이지를 불러와서 계속 실행하는 것이 아닌,
> 
> 메모리가 부족하면 프로세스를 정리하거나 종료
> 
> 하는 쪽을 선택한다.
> 

### 왜 iOS는 스왑을 쓰지 않을까?

- 모바일 저장장치는 RAM보다 **현저히 느림**
- 스왑은 **배터리 소모 증가**
- 사용자 경험(UX) 측면에서 **느려지는 앱보다 종료되는 앱이 낫다**

이 때문에 iOS는 페이지 폴트가 잦아지는 상황 자체를 **위험 신호**로 간주한다.

### iOS에서 메모리가 부족하면 일어나는 일

1. **페이지 폴트 증가**
2. 커널이 메모리 압박(Memory Pressure)을 감지
3. 백그라운드 앱부터 순차적으로 종료
4. 그래도 부족하면 **포그라운드 앱도 종료 (OOM)**

### 그럼 가상 메모리 방식을 어떻게 사용한다는 거지..?

가상 메모리는 사용하지 않는 메모리를 디스크에 저장하고 필요할 때 꺼내쓰는 방식으로 알고있었는데..?

결론부터 말하면:

> iOS는 ‘디스크 스왑 기반 가상메모리’가 아니라
‘파일 매핑 + 즉시 회수(reclaim) 중심의 가상메모리’를 사용한다.
> 

1. **가상 메모리가 무조건 스왑은 아니다**
    
    스왑 방식은 가상 메모리 구현 방식 중 하나일 뿐이다.
    
    가상 메모리의 본질은 아래와 같다.
    
    > 프로세스에게 “연속적이고 큰 주소 공간”을 제공하고
    실제 물리 메모리와의 매핑을 OS가 관리한다
    > 
2. **iOS는 `파일 기반 가상 메모리`를 적극 사용한다.**
    
    Clean Page(File-backed memory) → 디스크와 이미 연결된 메모리
    
    대표적인 예:
    
    - 앱 바이너리(code)
    - Framework 코드
    - mmap 된 파일
    - 읽기 전용 데이터
    
    이 페이지들은:
    
    - 메모리에 없어도 됨
    - 필요하면 **파일에서 다시 읽으면 됨**
    - 메모리 압박 시 **즉시 버려도 안전**
3. iOS에서 페이지 폴트는 아래와 같이 동작
    
    **파일 기반 페이지**
    
    1. 접근
    2. 메모리에 없음 → Page Fault
    3. 디스크의 원본 파일에서 읽어옴
    4. 정상 실행
    
    **Anonymous Page (힙 등)**
    
    1. 메모리 압박 발생
    2. 되살릴 곳 없음
    3. 시스템 전체 안정성을 위해 **앱 종료(OOM)**

이 외에도 더 자세한 방식들이 있지만 더 깊게 다루지는 않겠다.

> 즉 iOS의 가상 메모리는 모바일 기기 특성에 따라
디스크로 미루지 않고 버릴 수 있는 건 즉시 버리고, 못 버리면 앱을 종료한다.
>
