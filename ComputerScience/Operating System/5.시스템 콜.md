# 시스템 콜(system call)
앞 선 글에서 시스템 콜에 대해서 많이 언급을 했을 것이다. 사용자 프로그램이 디스크 파일을 접근하거나 화면에 결과를 출력하는 등의 작업이 필요한 경우, 즉 사용자 프로그램이 특권 명령의 수행을 필요로 하는 경우 운영체제에게 특권 명령의 대행을 요청해야 한다. 이때 커널 기능을 요청하는 통로가 시스템 콜이다. 

 즉, **시스템 호출(system call)**은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 **인터페이스**라고 정리할 수 있다.

통상적으로 시스템 콜은 여러 종류의 기능으로 나누어진다. 각 시스템 콜에는 번호가 할당되며, 시스템 콜 인터페이스는 **시스템 콜 번호와 시스템 콜 핸들러 함수 주소로 구성되는 시스템 콜 테이블(System Call Table)** 을 유지한다. 사용자 프로그램이 시스템 콜을 호출하면 trap/syscall 명령을 통해 커널 모드로 전환되고, 운영체제는 시스템 콜 번호를 이용해 테이블에서 해당 핸들러를 찾아 실행한다. 작업이 완료되면 커널은 결과 값을 반환하고 다시 사용자 모드로 복귀한다.

---

## 시스템 콜이 필요한 이유

앞서 운영체제의 역할을 학습하며 반복적으로 등장했던 개념이 있는데, 바로 **유저 모드와 커널 모드 분리**이다. 운영체제는 시스템 콜(System Call)을 통해 이 구조를 실제로 구현하고 있다.

우리가 일반적으로 사용하는 프로그램은 ‘응용 프로그램’이다. 응용 프로그램(유저 프로세스)은 유저 레벨의 함수만으로는 하드웨어 제어, 파일 I/O, 프로세스 관리 등 많은 기능을 직접 수행할 수 없기 때문에 운영체제 커널(kernel)의 도움을 받아야 한다.

하지만 이러한 기능은 시스템 전체에 영향을 줄 수 있는 **특권 동작(Privileged Operation)** 이므로 유저 모드(user mode)에서는 수행할 수 없다. 반드시 커널 모드(kernel mode)로 전환된 이후에만 수행 권한이 생긴다.

그렇다면 권한은 왜 필요할까?

만약 모든 프로그램이 하드웨어나 커널 기능을 제한 없이 호출할 수 있다면, 악의적인 공격자가 시스템을 손상시키거나 또는 개발자의 실수로 운영체제 전체가 불안정해질 수 있다. 그래서 운영체제는 입출력 장치 접근, 프로세스 제어 등 위험한 기능을 **커널 모드에서만 수행할 수 있도록 제한(Protection)** 한다.

따라서 사용자 프로그램이 커널 기능을 사용하려면 시스템 콜을 호출해야 하며, 이때 프로그램은 `syscall/trap`과 같은 명령(소프트웨어 인터럽트)을 통해 의도적으로 커널 모드로 진입한다. 반면 유저 모드에서 특권 명령을 직접 실행하거나 허용되지 않은 자원/메모리에 접근할 경우, 운영체제는 이를 **예외(Exception)** 로 처리하여 프로그램을 종료하거나 접근을 차단한다(예: 잘못된 메모리 접근으로 인한 crash).

---

## 소프트웨어 인터럽트 / Trap VS 시스템 콜 / System Call

개인적으로 시스템 콜 테이블, 시스템 콜 핸들러등의 용어가 나오면서 벡터테이블과 인터럽트 핸들러와는 뭐가 다르지? 그럼 시스템 콜과 소프트웨어 인터럽트는 같은 것인가? 라는 궁금증이 생겼다.

우선 한줄로 정리하자면 아래와 같다.

> 시스템 콜은 사용자 프로그램이 커널 기능을 요청하는 인터페이스이고, 이 요청을 전달하기 위해 보통 trap(소프트웨어 인터럽트)을 사용하여 커널 모드로 진입한다. 따라서 시스템 콜은 소프트웨어 인터럽트 메커니즘을 사용하는 대표적인 사례이다.
> 

### 소프트웨어 인터럽트(Software Interrupt) / Trap

- “하드웨어 장치가 갑자기 일으키는 인터럽트”가 아니라,
- **CPU가 특정 명령(trap/syscall/int/svc)** 을 실행했을 때
- **의도적으로 커널로 넘어가게 만드는 메커니즘**

> 커널 모드로 진입하기 위한 ‘문’
> 

### 시스템 콜(System Call)

- 운영체제가 제공하는 기능(파일 I/O, 프로세스 관리 등)을
- **사용자 프로그램이 요청하는 인터페이스(API)**

> 요청하는 기능 자체(또는 그 인터페이스)
> 

### 정확한 관계 설명

> 시스템 콜은 “커널 기능 요청”이고,
그 요청을 전달하기 위해 “소프트웨어 인터럽트(trap)”를 사용한다.
> 

이해가 되지 않았다면, 아래 **시스템 콜이 수행되는 과정**을 보면 더 확실히 이해할 수 있을 것이다.

---

## 시스템 콜이 수행되는 과정

시스템 콜은 사용자 프로그램(User mode)이 커널 기능(Kernel mode)을 사용하기 위해 커널에게 요청을 보내는 방식이다.

이 과정에서 CPU는 **유저 모드 → 커널 모드 전환** 을 수행하며, 운영체제는 안정성과 보안을 위해 사용자의 요청을 검증하고 처리한다.

### 1. 사용자 프로그램이 시스템 콜 함수 호출

예를 들어 파일을 읽을 때:

- `read()`
- `open()`
- `write()`

와 같은 시스템 콜 함수를 호출한다.

> 우리가 코드에서 호출하는 `read()` 같은 함수는 보통 **유저 영역의 wrapper(라이브러리 함수)** 이고, 실제 핵심 처리는 **커널 코드**가 수행한다.
> 

### 2. 시스템 콜 번호(Syscall Number)와 인자 준비

시스템 콜은 종류가 매우 많기 때문에, 운영체제는 각 시스템 콜에 **번호**를 부여한다.

- syscall number (예: read는 몇 번, write는 몇 번…)
- argument (fd, buffer, size 등)

사용자 프로그램은 syscall을 호출하기 전에 **레지스터/스택에 번호와 인자를 세팅**한다.

### 3. trap/syscall 명령 실행 → 커널 모드 진입

프로그램은 `syscall`, `trap`, `svc` 같은 특수 명령을 실행하여 커널 모드로 들어간다.

이 순간 CPU가 수행하는 일은:

- **모드 비트 전환(User → Kernel)**
- 현재 실행 상태 저장 (PC, register 등)
- 커널 진입점으로 점프

### 4. 커널이 시스템 콜 핸들러 진입

커널에 들어오면 **시스템 콜 처리 루틴**이 실행된다.

### 5. 시스템 콜 번호 확인 → 시스템 콜 테이블 참조

커널은 전달받은 syscall number를 통해 System Call Table에서 해당 번호가 가리키는 핸들러 주소를 찾아간다.

예:

- `sys_read`
- `sys_open`

### 6. 인자 검증 + 권한 검사 (보안 핵심)

커널은 절대 사용자를 믿지 않는다. 그래서 반드시 검사한다.

- buffer 포인터가 유효한지
- 해당 메모리가 사용자 주소공간인지
- 접근 권한이 있는지
- 파일 디스크립터(fd)가 올바른지

### 7. 커널 기능 수행 (실제 작업)

여기서부터 진짜 “운영체제가 일한다”.

예를 들어 `read()`라면:

- 파일 시스템 계층
- 버퍼 캐시
- 디바이스 드라이버
- 실제 디스크 I/O

까지 이어진다.

> I/O 작업은 느릴 수 있기 때문에 커널은 프로세스/스레드를
Running → Blocked 로 바꾸고, 다른 작업을 실행하도록 스케줄링할 수 있다.
> 

### 8. 결과 반환 값 설정

커널은 결과를 정리해서 반환한다.

- 성공: 0 또는 양수
- 실패: -1 및 errno 설정 (permission denied 등)

### 9. return-from-trap → 유저 모드 복귀

커널 처리가 끝나면 CPU는

- 저장했던 레지스터/PC 복구
- 모드 비트 변경(Kernel → User)
- 유저 코드로 복귀

사용자 프로그램 입장에서는 시스템 콜이 “그냥 함수 호출처럼” 끝난 것처럼 보인다.

### 결과 및 정리

한 줄 정리하자면 시스템 콜은 사용자 프로그램이 trap/syscall을 통해 커널로 진입한 뒤, 시스템 콜 테이블을 통해 해당 커널 함수를 실행하고 결과를 반환하는 구조이다.

~~이 과정을 봤을 때 궁금한 점이 생겼다. 만약 read()를 통해 파일 내용을 읽는다면, 8번 결과 반환 값을 성공 실패로 받는데, 파일 내용은 어떻게 받지..? 였는데, 바보같은 생각이었다.. 7번에서 사용자 버퍼에 채워줘서 사용자는 버퍼를 확인하는 것이었던 것..~~

만약 권한이 없는 시스템 호출을 했을 경우에는 어떻게 될까?

예를 들어 

iOS에서 앱이 다른 앱의 파일에 접근하려고 하면:

- 앱은 `open()`을 호출할 수는 있음 (시스템 콜 진입 가능)
- 하지만 커널의 **Sandbox policy**가 “너는 이 경로 접근 불가”라고 판단
- 그래서 `open()`이 실패로 끝남

---

## 시스템 콜의 종류

### 프로세스 생성/제어

- `fork()`
    - 프로세스 생성(부모 복제)
    - 부모 프로세스를 기반으로 **자식 프로세스 생성**
    - `fork()`의 반환값 의미
        - 부모: 자식 PID
        - 자식: 0
    - 부모/자식이 **같은 코드부터 계속 실행**한다는 점
    - Copy-on-Write
- `exec()`
    - 프로세스 메모리 이미지를 다른 프로그램으로 덮어씌움
    - 현재 프로세스의 주소 공간을 새 프로그램으로 교체
    - PID가 유지된다는 점이 핵심, 그래서 보통 **fork 후 exec** 패턴으로 사용됨
- `wait() / waitpid()`
    - 자식 프로세스 종료 기다림, 종료 상태 받음
    - 자식 exit status 수집
    - **좀비 프로세스 방지**
- `exit()`: 프로세스 종료

### fork-exec-wait 패턴

유닉스(Unix) 계열 운영체제에서는 새로운 프로그램을 실행할 때 보통 아래 3단계를 따른다.

1. `fork()` : 자식 생성
2. `exec()` : 자식이 실행할 프로그램 교체
3. `wait()` : 부모가 자식 종료 기다림

> 이 패턴은 “프로세스를 만드는 행위”와 “실행할 프로그램을 지정하는 행위”를 분리해서 유연하게 처리하기 위해서이다
> 

부모 프로세스는 `fork()`로 자식을 만든 뒤, 자식에게

- 어떤 프로그램을 실행할지(exec)
- 어떤 파일로 입출력을 연결할지
- 권한을 어떻게 줄지

등을 설정한 다음 실행하게 할 수 있다.

> wait를 하지 않으면 자식이 종료된 후에도 부모에게 프로세스 정보를 전달하지 못하고, 프로세스 테이블에 최소 정보가 남아 좀비 프로세스가 될 수 있다.
> 

### 파일/디스크 I/O

- `open()`, `close()`
- `read()`, `write()`
- `lseek()`
- 파일 디스크립터(fd) 개념

### 메모리 관리

- `brk()/sbrk()` (heap 확장)
- `mmap()` (메모리 매핑)
- `munmap()`

### 프로세스 간 통신(IPC)

- `pipe()`
- `socket()`
- `shm*` (shared memory 계열)

### 네트워크

- `socket()`, `bind()`, `listen()`, `accept()`
- `connect()`, `send()`, `recv()`

### 권한/보안

- Permission 획득
- Permission 설정

---

## iOS 개발자 관점에서의 System Call

iOS 앱 개발자는 `fork()`, `exec()` 같은 시스템 콜을 직접 호출할 일은 거의 없다. iOS는 보안과 안정성을 위해 앱이 임의로 프로세스를 생성하거나 다른 프로그램을 실행하는 것을 제한하며, 앱은 샌드박스(Sandbox) 환경 안에서 동작한다.

하지만 iOS 앱이 사용하는 대부분의 기능은 내부적으로 **시스템 콜을 통해 커널 서비스를 사용**하는 구조로 이루어져 있다. 예를 들어 `URLSession`을 통한 네트워크 통신, 파일 읽기/쓰기(FileManager), 타이머, 스레드 스케줄링 등은 고수준 API로 제공되지만, 결국 커널의 네트워크 스택/파일 시스템/프로세스 및 스레드 관리 기능을 호출하게 된다.

또한 시스템 콜은 커널 모드에서 수행되며, 파일 접근 권한이나 네트워크 권한(샌드박스, entitlement, permission) 검사는 커널 레벨에서 수행된다. 따라서 iOS 개발자는 시스템 콜 자체보다는, 시스템 콜이 만드는 특성인 **비동기 I/O**, **메인 스레드 UI 규칙**, **권한/샌드박스 모델**, **성능(블로킹/컨텍스트 스위칭)** 등을 이해하는 것이 중요하다.
