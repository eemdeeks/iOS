# 데드락(DeadLock, 교착 상태)
**데드락(DeadLock)**이란 두 개 이상의 프로세스(또는 스레드)가 자원을 점유한 상태에서, **서로가 점유한 자원을 추가로 요구하며 대기함으로써** 모든 실행 흐름이 **무한정 멈추는 상태**를 말한다. 이는 시스템에서 한정된 자원(예: 락, CPU, IO 디바이스)을 여러 실행 주체가 경쟁적으로 획득하는 과정에서 발생하며, 특히 **환형 대기(Circular Wait)** 구조가 형성될 때 데드락이 성립할 수 있다.

### 데드락이 일어나는 경우

예를 들어 프로세스 1과 2가 각각 자원 1과 자원 2를 필요로 한다고 하자.

프로세스 1이 자원 1을 획득하고, 프로세스 2가 자원 2를 획득한 상황에서 프로세스 1이 자원 2를 요청하고, 프로세스 2가 자원 1을 요청한다면, 두 프로세스는 서로가 가진 자원을 기다리며 영원히 진행하지 못한다.

이처럼 **서로 원하는 자원이 상대에게 이미 할당되어 있어 무한히 대기하는 상태**가 데드락이다.

## 데드락 발생의 4가지 필요 조건 (Coffman Conditions)

> 아래의 4가지 조건이 **모두 만족될 때 데드락이 발생할 수 있다.**
> 
> 
> → `하나라도 만족하지 않으면 발생하지 않는다.` 
> → `즉, 하나라도 성립하지 않게 한다면 데드락 문제를 해결 가능하다.`
> 

### 1. 상호 배제 (Mutual exclusion)

- 한 리소스는 **한 번에 하나의 프로세스(또는 스레드)만** 사용할 수 있다.
- 다른 실행 주체가 사용 중인 자원을 필요로 할 경우, 해당 자원이 해제될 때까지 기다려야 한다.

### 2. 점유와 대기(Hold and wait)

- 어떤 프로세스(또는 스레드)가 **자원을 하나 이상 점유한 상태로**, 다른 자원(현재 다른 프로세스에 의해 점유 중)을 얻기 위해 대기하는 상황이 존재해야 한다.

### 3. 비선점 (No preemption)

- 이미 다른 프로세스에게 할당된 자원은 **강제로 빼앗을 수 없다.**
- 자원은 해당 프로세스가 작업을 완료한 뒤 **자발적으로 반환(release)** 해야만 한다.

### 4. 환형 대기 (Circular wait)

- 대기 중인 프로세스들의 집합이 **순환 형태(cycle)**로 자원을 기다리는 구조가 존재해야 한다.
- 예) P1은 P2가 가진 자원을 기다리고, P2는 P1이 가진 자원을 기다리는 상태

## 데드락의 해결법

위에서도 언급 했지만 데드락 발생의 4가지 필요 조건 중 한가지만 성립하지 않게 해도 문제를 데드락을 해결 할 수 있으며 이 외에도 해결법들이 있다. 데드락의 해결법은 크게 아래 3가지로 분류할 수 있다.

1. 데드락이 발생하지 않도록 **`예방(prevention)`**
2. 데드락 발생 가능성을 인정하면서 **`회피(avoidance)`**
3. 데드락 발생을 허용하되 **`탐지(detection)`**  후  **`회복(recovery)`**

### 1. 예방 (Prevention)

> 데드락의 4가지 필요 조건 중 **하나 이상이 성립하지 않도록** 설계하여 데드락을 원천 차단하는 방식
> 

즉, 각각의 조건을 방지하여 데드락 발생 가능성을 차단한다.

다만 예방은 데드락 조건을 제거하기 위해 **자원 활용률과 병렬성을 희생**하는 경우가 많아 비효율적이다.

1. **상호 배제 조건 방지**
    - 공유 자원을 여러 프로세스가 동시에 사용할 수 있도록 설계한다.
    - 단, 많은 자원은 본질적으로 공유가 불가능하므로 제한적으로만 적용 가능하다. (동기화 문제 등 발생)
2. **점유와 대기 조건 방지**
    - 필요한 자원을 한번에 요청하도록 하거나, 모든 자원을 확보할 때까지 실행을 보류한다.
    - 프로세스 실행 전, 모든 자원을 할당.
3. **비선점 조건 방지**
    - 프로세스가 점유한 자원을 다른 프로세스가 **강제로 빼앗을 수 있게 하기(선점).**
    - 자원 점유 중인 프로세스가 **다른 자원을 요구할 때 가진 자원 반납.**
4. **순환 대기 조건 방지**
    - 자원에 순서를 부여하고, 해당 순서대로만 요청하도록 제한한다.

### 2. 회피 (Avoidance)

> 교착상태가 발생할 가능성을 배제하지 않되, 자원 할당 과정에서 교착 상태를  피해나가는 방법
> 
- 리소스 할당의 측면에서, **교착상태가 발생할 가능성이 있는 자원을 할당하지 않는 방법이다.**
- Safe state, Unsafe state
    - "안전상태"와 "불안전 상태"
    - 교착 상태에 빠질 수 있는지 판단을 하여 나눈 상태
    - 불안전 상태의 경우에 OS가 자원을 할당을 하면 교착상태에 빠질 수 있다는 것이다.
- 자원을 할당한 후에도 시스템이 항상 `Safe state`에 있을 수 있도록 할당을 허용하자는 것.
- 대표적인 알고리즘으로 `은행원 알고리즘(Banker's Algorithm)`이 있다.

> **은행원 알고리즘(Banker's Algorithm)**
**자원 할당 요청이 들어올 때마다**, 그 요청을 허용했을 때도 시스템이 **Safe State**(안전 상태)를 유지할 수 있는지 미리 검사검사한다.
다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래됐다. **“이 돈을 빌려줘도 은행이 파산하지 않을까?”**
> 
- 그러나 각 프로세스의 **최대 자원 요구량(Max)**을 사전에 정확히 알아야 하며, 프로세스 수/자원 수가 많으면 매 요청마다 검사 해야한다. → **오버헤드 큼**
- 자원 이용률이 떨어질 수 있다. (항상 안전하게만 주니까)

### 3. 탐지 및 회복 (Detection and Recovery)

> 데드락 발생을 허용하지만, **탐지 후 회복 절차로 교착 상태를 해소**하는 방식
> 

### 탐지

- 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견한다.
- **데드락 탐지 알고리즘** 또는 **자원 할당 그래프**를 이용한다.
- 자원 요청시, 탐지 수행하는데 빈도가 높아질수록 오버헤드가 커진다는 단점이 있다.

### 회복

- 교착상태 발견시 회복을 진행한다.
- 회복 방법으로는 **프로세스 종료** 또는 **할당된 자원 선점**하는 방법이 있다.
1. **프로세스 종료**
    - 데드락 관련 프로세스 모두 종료
    - 데드락이 해소될 때까지 한 프로세스씩 종료
2. **자원 선점 방법**
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당
    - 회수된 프로세스는 강제 종료 후 재시작하거나 rollback 등을 수행
    - 우선 순위가 낮거나 수행 횟수가 적은 프로세스 위주로 자원 선점

### + 교착 상태 무시

마지막은 해결방법은 아니지만 무시하는 방법이 있다. 데드락 상황이 흔한 상황이 아니기도 하고, 실제로 잘 일어나지 않기도 한다. 이를 해결하기 위해 발생하는 오버헤드가 크기 때문에 사용자는 단순히 프로세스를 재시작 하는 방법등을 사용할 수 도 있다. 이렇게 데드락 상황 자체를 무시하는 방법도 있다.

---

## 데드락과 같이 나오는 동시성 문제들

## 1. Livelock (라이브락)

> 서로 양보/회피 동작만 계속해서 멈춘 건 아닌데 진행이 없음
> 
- Deadlock: 멈춰 있음
- Livelock: 바쁘게 움직임(상태가 바뀜)인데 결과적으로 아무것도 못함

### 특징

- 진행(progress) = ❌
- CPU 사용량 = ✅ 높을 수 있음 (계속 반복)

### 예시

- Thread A: “B가 하고 있네? 그럼 내가 양보할게”
- Thread B: “A가 하고 있네? 그럼 나도 양보할게”
- 둘 다 계속 양보만 해서 작업이 진행 안 됨

## 2. Starvation (기아)

> 특정 스레드/작업이 계속 자원 배정을 못 받아서 영원히 실행 못함
> 
- Deadlock은 서로 기다리는 사이클 구조.
- Starvation은 “밀려서 못 받는” 문제.

### 특징

- 시스템은 돌아가고 있다.
- 특정 작업만 계속 끝내지 못한다.
- “무한 대기”처럼 보이지만 원인이 **데드락이 아니라 스케줄링/우선순위 문제**인 경우가 많다.

### iOS에서 흔한 예

- 낮은 우선순위 task가 계속 밀림
- concurrent queue에서 높은 우선순위 작업이 쏟아져서 특정 작업이 실행되지 못함

## 3. Priority Inversion (우선순위 역전)

> 낮은 우선순위 작업이 잡고 있는 자원 때문에
> 
> 
> 높은 우선순위 작업이 기다리게 되어 **우선순위가 뒤집히는 현상**
> 

### 예시

- Low priority thread가 lock을 잡고 작업 중
- High priority thread가 그 lock이 필요해서 기다림
- Medium priority thread들이 CPU를 계속 먹어버리면
- Low는 lock을 풀 시간도 없고 → High는 계속 기다림
