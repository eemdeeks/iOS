# 세마포어(Semaphore)와 뮤텍스(Mutex)
앞서 경쟁 상태(Race Condition)를 학습하면서 **임계 구역(Critical Section)** 에 대해 살펴보았다.

임계 구역이란 공유 자원에 여러 프로세스나 스레드가 동시에 접근할 경우, **데이터의 일관성이 깨질 수 있는 코드 영역**을 의미한다. 이러한 문제를 해결하기 위해서는 공유 자원에 **한 번에 하나의 프로세스 또는 스레드만 접근할 수 있도록 제한**하여 동기화(Synchronization)를 보장해야 한다.

이때 사용되는 대표적인 동기화 도구가 **세마포어(Semaphore)** 와 **뮤텍스(Mutex)** 이다.

# 세마포어(Semaphore, Counting Semaphore)란?

세마포어를 설명할 때 흔히 **화장실과 열쇠** 비유를 사용한다.

카페에 화장실이 3개 있고, 카운터에 화장실 열쇠가 3개 있다고 가정해보자.

화장실이 모두 비어 있다면 카운터에는 열쇠 3개가 놓여 있고, 사람 한 명이 화장실을 사용할 때 열쇠 하나를 가져간다.

만약 열쇠가 모두 사용 중이라면(열쇠가 0개라면), 다른 사람은 누군가가 화장실 사용을 마치고 열쇠를 반환할 때까지 기다려야 한다.

이처럼 **세마포어(Semaphore)** 는 공유 자원에 동시에 접근할 수 있는 **최대 개수를 제한**하는 동기화 도구이다.

- 공유 자원의 개수만큼 세마포어 값을 설정
- 자원을 사용할 때마다 값이 감소
- 값이 0이 되면 더 이상 접근할 수 없고 대기 상태
- 자원을 반납하면 값이 다시 증가

## wait(), signal()

세마포어를 사용할 때 핵심이 되는 연산은 `wait()` 와 `signal()` 이다.

전통적으로는 각각 **P 연산**, **V 연산** 이라고도 불린다.

(세마포어 값은 보통 **`S`**로 표현한다.)

### wait() - P Operation

`wait()` 연산은 **임계 구역에 진입하기 전에 수행**된다.

- 세마포어 값 `S` 가 **0보다 크다면**
    - `S = S - 1`
    - 자원을 획득하고 임계 구역에 진입한다
- 세마포어 값 `S` 가 **0이라면**
    - 사용 가능한 자원이 없으므로 다른 스레드/프로세스가 자원을 반납할 때까지 **대기 상태**에 들어간다

> 즉, `wait()` 은 **“자원이 있으면 하나 가져가고, 없으면 기다린다”** 는 의미이다.
> 

### signal() - V Operation

`signal()` 연산은 **임계 구역을 빠져나올 때 수행**된다.

- 자원 사용이 끝났음을 알리는 동작
- 세마포어 값을 증가시킴

> S = S + 1
> 

이때, 대기 중인 스레드나 프로세스가 있다면 그중 하나가 자원을 획득할 수 있다.

> 즉, `signal()` 은 **“자원 하나를 반납한다”**는 의미이다.
> 

## Busy-Waiting → Block-Wakeup

세마포어를 구현하는 방식은 크게 **Busy-Waiting**방식과 이를 개선한 **Block-Wakeup** 방식으로 나눌 수 있다.

### Busy-Waiting

Busy-Waiting은 세마포어의 초기 구현 방식으로, 임계 구역에 진입해야 하는 프로세스가 **조건이 만족될 때까지 반복문을 계속 실행하며 기다리는 방식**이다.

```c
P(S) {
    while S <=0;
    S--;
}

V(S) {
    S++;
}
```

위 코드에서 볼 수 있듯이, 세마포어 값 `S` 가 0 이하라면 `while` 문을 빠져나오지 못하고 CPU를 점유한 채 계속 조건만 검사하게 된다

이 방식의 가장 큰 문제는 **CPU 자원을 낭비한다는 점**이다. 실제로는 아무 작업도 하지 않지만 스레드/프로세스는 계속 실행 상태(Running)에 머무르며 다른 작업이 CPU를 사용할 기회를 빼앗게 된다

### Block-Wakeup

Busy-Waiting의 비효율성을 해결하기 위해 등장한 방식이 **Block-Wakeup** 방식으로 **Wait Queue(대기 큐)** 를 사용한다.

자원이 부족하면 해당 프로세스를 block()을 통해 Wait Queue에 대기 시키고, 자원이 생기면 대기 큐에서 꺼내 wakeup()을 통해 실행 상태로 만든다.

```bash
P(S) {
    S--;
    if S < 0
        block(); 
}

V(S) {
    S++;
    if S <= 0
        wakeup(); 
}
```

이 방식은 자원이 없을 때 **CPU를 점유하지 않으며**, 프로세스는 **Blocked 상태**로 전환되어 스케줄링 대상에서 제외된다**.** 즉, **CPU를 낭비하지 않고 효율적으로 자원을 관리할 수 있다.**

# 뮤텍스(Mutex) 란?

**뮤텍스(Mutex, Mutual Exclusion)**는 공유 자원을 사용하는 코드 영역을 **한 번에 하나의 스레드만 실행할 수 있도록 보장하는 동기화 기법**이다.

뮤텍스는 기본적으로 **Lock / Unlock** 개념을 사용한다.

- Lock을 획득한 스레드만 임계 구역에 진입할 수 있음
- Lock을 해제해야 다른 스레드가 진입할 수 있음

이번에는 화장실이 **1개**, 열쇠도 **1개**라고 가정해보자.

화장실에 처음 들어간 사람은 열쇠를 들고 들어가 문을 잠근다.

화장실에 처음 들어간 사람이 열쇠를 들고 들어가, 문을 잠군다. 그렇다면 다음 사람이 들어가려고 해도 문이 잠겨있고 열쇠가 없으니 들어가지 못한다. 또한 안에 있던 사람이 나와 열쇠를 반납해야 다른 사람이 들어갈 수 있게 된다.

이처럼 뮤텍스는 **공유자원 하나, 접근 가능한 스레드 한개** 라는 특징이 있다.

즉, 뮤텍스는 하나의 공유자원에 대해 상호 배제(Mutual Exclusion)을 보장한다.

## 뮤텍스 기법

뮤텍스를 구현하기 위한 고전적인 알고리즘으로는 다음과 같은 방법들이 있다.

- **데커(Dekker) 알고리즘**
- **피터슨(Peterson) 알고리즘**
- **제과점(Backery) 알고리즘**

이 알고리즘들은 **하드웨어 지원 없이 소프트웨어만으로 상호 배제를 구현**하기 위해 고안되었다. 그래서 살짝 고전적 알고리즘으로 분류된다.

### 데커(Dekker) 알고리즘

`flag`와 `turn` 변수를 통해 두 프로세스/스레드 중 누가 임계 구역에 진입할지 결정하는 방식이다.

- `flag[i]`
    - 프로세스 i가 임계 구역에 진입하려는 의사가 있는지 나타내는 변수
- `turn`
    - 어떤 프로세스/스레드가 임계 구역에 들어갈 우선권이 있는지 나타내는 변수

```c
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    
    while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
        if(turn == j) { // j가 임계 구역 사용 중이면
            flag[i] = false; // 프로세스 i 진입 취소
            
            while(turn == j); // turn이 j에서 변경될 때까지 대기
            
            flag[i] = true; // j turn이 끝나면 다시 진입 시도
        }
    }
}

// ------- 임계 구역 ---------

turn = j; // 임계 구역 사용 끝나면 turn을 넘김
flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림

```

상호 배제, 진행 조권, 유한 대기 조건을 만족하지만 두 프로세스만 처리 가능하다는 한계가 있다.

### 피터슨(Peterson) 알고리즘

데커 알고리즘을 단순화한 방식으로, 상대방 프로세스/스레드에게 진입 기회를 양보하는 차이가 있다.

```c
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    turn = j; // 다른 프로세스에게 진입 기회 양보
    
    while(flag[j] && turn == j) { 
            // 다른 프로세스가 진입 시도하면 대기
    }
}

// ------- 임계 구역 ---------

flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
```

이는 데커보다 구현이 간단하며 두프로세스 간 상호 배제가 보장되지만, 이 또한 두 프로세스만 처리 가능하다.

### 제과점(Bakery) 알고리즘

빵집에서 고객들에게 번호표를 부여하여 기다리는 방식에서 착안한 알고리즘이다.

각 프로세스/스레드는 번호표를 받으며, 번호가 가장 작은 프로세스/스레드가 임계 구역에 진입하는 방식이다. 이 방식은 위 방식들과 다르게 여러 프로세스/스레드를 동시에 처리할 수 있다.

```c
while(true) {
    isReady[i] = true; // 번호표 받을 준비
    number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 
    isReady[i] = false; // 번호표 수령 완료
    
    for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
        while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
        while(number[j] && number[j] < number[i] && j < i);
        
        // 프로세스 j가 번호표 가지고 있어야 함
        // 프로세스 j의 번호표 < 프로세스 i의 번호표
    }
}

// ------- 임계 구역 ---------

number[i] = 0; // 임계 구역 사용 종료
```

## 세마포어와 뮤텍스의 차이점

세마포어와 뮤텍스는 모두 **임계 구역을 보호하기 위한 동기화 도구**이지만, 설계 목적과 사용 방식에는 분명한 차이가 있다.

### 동기화 대상의 개수

- **Mutex**
    - 공유 자원이 **오직 1개**일 때 사용
    - 한 번에 **하나의 스레드만** 접근 가능
- **Semaphore**
    - 공유 자원이 **1개 이상**일 때 사용
    - 설정한 카운트만큼 **여러 스레드 접근 가능**

### **세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.**

- Mutex는 상태가 **0 또는 1**만 존재하는 **이진 락(Binary Lock)** 이다. 이 때문에 Mutex는 **Binary Semaphore**의 특수한 형태로 볼 수 있다.
- 반면 Semaphore는 **카운트 값(0 이상)** 을 가질 수 있으므로 더 일반적인 개념이다.

### **자원 소유 개념의 차이**

- **Mutex**
    - **자원 소유 개념이 명확**하다.
    - Lock을 획득한 스레드가 해당 자원의 **소유자(owner)** 가 된다.
    - Lock / Unlock은 반드시 **같은 스레드**에서 이루어져야 한다.
    - `lock`
        - 임계 구역에 들어갈 권한을 획득
        - 이미 다른 스레드가 lock을 보유 중이면 대기
    - `unlock`
        - 임계 구역 사용이 끝났음을 알림
        - 대기 중인 다른 스레드가 진입 가능
- **Semaphore**
    - **자원 소유 개념이 없다**
    - 단순히 “사용 가능한 자원의 개수”만 관리한다
    - 누가 `wait()` 했는지와 관계없이, **다른 스레드가 `signal()` 가능**

### 해제 권한의 차이

**뮤텍스는 소유하고 있는 스레드만이 이 뮤텍스를 해제할 수 있다**

- **Mutex**
    - **Lock을 획득한 스레드만 Unlock 가능**
    - 소유권이 엄격하게 보장됨
- **Semaphore**
    - `wait()`을 호출한 스레드가 아니어도 `signal()` 가능
    - 소유 개념이 없기 때문

> 이 차이 때문에 Mutex는 **임계 구역 보호,** Semaphore는 **자원 수 조절 / 작업 흐름 제어**에 더 자주 사용된다.
> 

### 범위와 생명 주기 관점의 차이

- **Semaphore**
    - 프로세스 간 동기화(Inter-Process Synchronization)에 사용 가능
    - 운영체제 수준에서 관리되는 경우가 많다
- **Mutex**
    - 주로 **프로세스 내부 스레드 간 동기화**에 사용
    - 프로세스 종료 시 자동으로 정리(clean-up) 된다

### 공통적인 한계점

Mutex와 Semaphore 모두

- 데이터 무결성을 **자동으로 보장해주지 않는다**
- 모든 **교착 상태(Deadlock)** 를 해결해주지는 않는다

위와 같은 한계점이 있지만 상호 배제를 위한 기본적인 기법이며, 

이와 함께 임계 구역을 어떻게 설계하고, 공유 상태를 얼마나 줄일것인지, 락을 언제 얼마나 짧게 잡을 것인가가 중요하다.

---

# iOS에서 Mutex와 Semaphore는 어떻게 쓰일까?

iOS에서는 운영체제 수준의 Mutex / Semaphore를 **직접 구현해서 쓰는 경우는 거의 없다.**

대신 Apple이 제공하는 **고수준 동기화 도구**를 사용한다.

중요한 건 해당 API가 뮤텍스인지 세마포어인지 잘 구분해서 쓰는 것이다.

## Mutex 계열 (상호 배제 목적)

> 한 번에 하나의 스레드만 임계 구역에 들어가야 할 때
> 

### NSLock

```swift
let lock = NSLock()

lock.lock()
// critical section
lock.unlock()
```

iOS에서 가장 기본적인 **뮤텍스**이며**,** lock을 건 스레드만 unlock 가능 하다.

---

### os_unfair_lock (저수준, 고성능 Mutex)

```swift
import os.lock

var lock = os_unfair_lock()

os_unfair_lock_lock(&lock)
// critical section
os_unfair_lock_unlock(&lock)
```

- iOS에서 권장되는 **저수준 mutex**
- spinlock의 단점을 개선한 방식
- **Priority Inversion을 고려한 설계**

아주 짧은 임계 구역에 사용하며, 성능 민감한 코드나 프레임 드랍, UI 레이턴시가 치명적인 경우에 사용한다.

주위 점으로 절대 오래 잡으면 안되며, Main Thread에서 장시간 사용하면 안된다. 이는 이름 그대로 Unfair(공정하지 않은)락으로 오래 기다린 스레드보다 지금 실행 중인 스레드가 락을 다시 잡는 걸 우선시한다. 주로 임계 구역이 아주 짧을 때 성능 극대화 하도록 설계되었다.

---

### Serial DispatchQueue (논리적 Mutex)

```swift
let queue = DispatchQueue(label:"com.example.lock")

queue.sync {
// critical section
}
```

실제 락은 아니지만 **결과적으로 mutex처럼 동작**하며**,** GCD가 스케줄링을 대신 관리한다.

Swift / GCD 를 사용하며 공유 자원을 “큐 단위”로 보호하고 싶을 때 사용한다.

iOS에서 **가장 많이 쓰이는 Mutex 대체 패턴이다.**

---

## Semaphore 계열 (자원 개수 제어 목적)

> 정해진 개수만큼만 동시에 허용하고 싶을 때
> 

### DispatchSemaphore

```swift
let semaphore = DispatchSemaphore(value:3)

semaphore.wait()
// critical section
semaphore.signal()
```

iOS에서 사용하는 **카운팅 세마포어**이며, value 파라미터를 통해 동시에 허용 가능한 작업 수를 조절할 수 있다.

주로 네트워크 요청 개수 제한, 동시에 실행 가능한 작업 수 제한, 비동기 작업의 “완료 대기”에서 사용한다.

```swift
let semaphore = DispatchSemaphore(value:1)
```

위 처럼 DispatchSemaphore로 Mutex처럼 쓰는 건 주의해야한다.

DispatchSemaphore는 소유 개념이 없어, 다른 스레드가 signal() 가능하다. 또한 실수로 signal()을 누락한다면 데드락이 될 수 있다.

---

## Swift Concurrency (Actor = 현대적 Mutex)

### Actor

```swift
actor Counter {
    var value = 0

    func increment() {
        value += 1
    }
}

```

Actor는 내부적으로 **상호 배제를 보장하며** 개발자가 락을 직접 관리할 필요 없다는 장점이 있다. 또한 **논리적으로 완성된 Mutex**이다.

iOS 최신 권장 방식이며, 공유 상태는 Actor 안에 가두어 관리가능하다.  이로 인해 락 실수 / 데드락 가능성 대폭 감소하는 장점이 있다.

> iOS에서는 Mutex와 Semaphore를 보통 직접 구현하지 않고,
> 
> 
> **NSLock / os_unfair_lock / Serial Queue / Actor** 로 상호 배제를,
> 
> **DispatchSemaphore** 로 동시 실행 개수를 제어한다.
>
