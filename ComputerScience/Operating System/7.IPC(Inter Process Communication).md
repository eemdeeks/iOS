# IPC(Inter-Process Communication, 프로세스 간 통신)
IPC(Inter-Process Communication, 프로세스 간 통신)는 **서로 다른 프로세스가 데이터를 주고받고 협력하기 위한 메커니즘**을 말한다. 운영체제에서 프로세스는 기본적으로 독립된 실행 단위이며, 각 프로세스는 자신만의 주소 공간(가상 메모리 공간)을 가진다. 이 때문에 다른 프로세스의 메모리에 직접 접근할 수 없고, 프로세스끼리 정보를 교환하거나 협업하려면 운영체제가 제공하는 IPC 수단을 사용해야 한다.

## 프로세스 간 통신이 필요한 경우

그렇다면 프로세스간 통신이 필요한 경우에는 무엇이 있을까?

프로세스는 스레드와 달리 메모리를 공유하지 않는다. 스레드는 같은 프로세스 내부에서 code/text, data, heap 영역을 공유할 수 있어 비교적 쉽게 데이터를 공유할 수 있지만, 프로세스는 서로 주소 공간이 완전히 분리되어 있기 때문에 직접 공유가 불가능하다.

따라서 다음과 같은 상황에서 IPC가 필요해진다.

1. **데이터 공유**
    
    서로 다른 프로세스가 동일한 데이터를 사용하거나 전달해야 하는 경우
    
2. **기능 분리(모듈성)**
    
    시스템 기능을 여러 프로세스로 분리하여 개발/유지보수를 쉽게 하고자 하는 경우
    
    (예: UI 프로세스, 백엔드 처리 프로세스를 분리)
    
3. **안정성(장애 격리)**
    
    하나의 프로세스에서 오류가 발생하더라도 다른 프로세스는 영향을 덜 받도록 분리하는 경우
    
    → 다만 분리된 프로세스끼리 결과를 주고받기 위해 IPC가 필요
    
4. **병렬 처리(성능)**
    
    계산을 여러 프로세스로 분산한 뒤 결과를 모아야 하는 경우
    
    → 계산 속도 향상(Computation speedup)의 효과를 얻을 수 있다.
    

# IPC의 대표적인 방법

## 1. 메시지 전달 방식 (Message Passing)

메시지 전달(Message Passing) 모델은 프로세스들이 **공유 메모리를 직접 공유하지 않고**, 운영체제가 제공하는 통신 수단을 통해 **메시지를 주고받는 방식**이다. 대표적으로 파이프(pipe), 소켓(socket), 메시지 큐(message queue) 등이 있다.

메시지 전달 방식에서는 보통 Producer가 `send()`를 통해 메시지를 전달하고, Consumer가 `receive()`를 통해 메시지를 받아 처리한다. 이 과정은 운영체제가 제공하는 **시스템 콜(system call)** 을 통해 이루어지며, send/receive 시점에 커널이 개입하여 데이터를 전달한다.

다만 커널이 통신을 중재하는 구조이기 때문에, 경우에 따라 데이터 복사나 컨텍스트 스위칭이 발생하여 **오버헤드(성능 비용)** 가 생길 수 있다. (특히 큰 데이터를 자주 주고받는 경우 공유 메모리 방식이 더 유리할 수 있다.)

<img width="252" height="293" alt="Image" src="https://github.com/user-attachments/assets/1898b1ba-d9f5-41d5-9987-6be4707f09cd" />

위 그림처럼 각 프로세스는 커널이 제공하는 통신 채널(예: 메시지 큐)에 메시지를 전달하고, 커널은 이를 다른 프로세스가 읽을 수 있도록 중재한다.

### 파이프 방식 (PIPE)

파이프(Pipe)는 프로세스 간 통신을 위해 운영체제가 제공하는 IPC 방식 중 하나로, 커널 내부에 **통신 버퍼(파이프 버퍼)** 를 생성하여 데이터를 주고받을 수 있게 해준다. 파이프는 두 프로세스를 연결하여 한쪽은 데이터를 쓰고(write), 다른 쪽은 데이터를 읽는(read) 방식으로 동작한다.

Unix 계열 운영체제는 파이프를 특수한 유형의 파일로 취급하기 때문에 `read()` / `write()` 시스템 콜을 통해 파이프에 접근할 수 있다.

파이프는 기본적으로 단방향(simplex) 통신 방식이며, 양방향 통신을 원한다면 보통 파이프를 2개 만들어 반이중(half-duplex) 형태로 사용할 수 있다.

파이프는 크게 **Ordinary Pipe(익명 파이프)** 와 **Named Pipe(FIFO)** 로 나뉜다.

- **Ordinary PIPE(익명 파이프, Anoymous pipe)**
    
    <img width="496" height="161" alt="Image" src="https://github.com/user-attachments/assets/d4443d63-0c51-4047-a366-a4a261a7d2db" />
    
    File descriptors for an ordinary pipe.
    
    Ordinary pipe는 이름이 없는 파이프이며, 파이프 생성 시 반환되는 파일 디스크립터(fd)를 **상속받거나 전달받을 수 있는 관계의 프로세스(주로 부모-자식)** 에서 사용된다. 즉, 통신할 프로세스가 명확히 정해져 있고 짧은 범위의 통신이 필요할 때 유용하다.
    
    또한 Ordinary pipe는 기본적으로 단방향이므로, 읽기와 쓰기(양방향 송수신)를 모두 원한다면 일반적으로 **파이프를 2개 생성해야 한다.**
    
- **Named PIPE(FIFO)**
    
    Named pipe는 이름을 가진 파이프로, 파일 시스템에 **FIFO 특수 파일 형태로 생성**된다. 따라서 서로 부모-자식 관계가 아닌 프로세스라도, 동일한 FIFO 파일에 접근할 수 있다면 통신이 가능하다.
    
    Named pipe는 `mkfifo` 명령(또는 관련 시스템 콜)을 통해 생성할 수 있으며, 생성된 FIFO 파일을 `open()` 한 뒤 `read()` / `write()` 시스템 콜로 데이터를 주고받는다.
    
    다만 Named pipe 또한 기본적으로 단방향 통신 구조이므로, 프로세스 간 양방향 통신을 위해서는 **FIFO 파일을 2개 사용하는 방식이 필요**하며 이는 경우에 따라 비효율적일 수 있다.
    

### 메시지 큐 (Message Queue)

메시지 큐(Message Queue) 또한 운영체제 커널이 관리하는 IPC 방식으로, 프로세스들이 커널 공간에 만들어진 **메시지 저장소(큐)** 를 통해 데이터를 주고받는 방식이다. 메시지 큐는 일반적으로 **FIFO(선입선출)** 구조를 기반으로 동작하며, 송신 프로세스는 메시지를 큐에 넣고(send), 수신 프로세스는 큐에서 메시지를 꺼내(receive) 사용한다.

메시지 큐는 파이프(pipe)나 FIFO처럼 커널이 통신을 중재한다는 점에서 유사하지만, 파이프가 주로 **바이트 스트림(stream)** 을 전달하는 형태라면 메시지 큐는 **메시지 단위(message-based)** 로 데이터를 주고받는다는 점에서 차이가 있다. 즉, 메시지 큐는 메시지의 경계가 보존되어 수신자가 “한 번에 한 메시지” 단위로 읽을 수 있다.

또한 pipe/FIFO는 기본적으로 두 프로세스 간의 단순한 연결에 가까운 반면, 메시지 큐는 하나의 큐를 여러 프로세스가 공유하여 **다수의 프로세스 간 통신**을 구성할 수 있다는 장점이 있다. 이때 메시지에는 타입(type)이나 우선순위(priority) 같은 값을 함께 지정할 수 있어, 여러 프로세스가 동시에 데이터를 주고받는 상황에서도 메시지를 구분하여 처리하기 용이하다.

다만 메시지 큐 역시 커널 공간에서 관리되는 자원이기 때문에 저장 가능한 메시지 크기나 큐 용량에 제한이 존재하며, 데이터 전달 과정에서 커널 개입에 따른 오버헤드가 발생할 수 있다

### **소켓(Socket)**

소켓(Socket)은 프로세스가 네트워크를 통해 데이터를 송수신할 수 있도록 운영체제가 제공하는 **통신 엔드포인트(endpoint)** 이다. 소켓은 단순히 “원격 통신”만을 위한 기술이 아니라, 같은 머신(동일 호스트) 내부에서도 프로세스 간 통신(IPC)으로 사용할 수 있다. 즉 소켓은 **범용 IPC 도구**이며, 로컬 통신과 네트워크 통신을 모두 지원한다.

운영체제는 프로세스가 소켓을 통해 통신할 수 있도록 소켓 API를 제공하며, 내부적으로는 커널의 네트워크 스택을 통해 데이터 송수신이 이루어진다.

소켓 통신은 일반적으로 **클라이언트(Client) ↔ 서버(Server)** 구조로 이루어진다.

- **서버 프로세스**는 특정 포트(port)에서 연결을 “대기(listen)”한다.
- **클라이언트 프로세스**는 서버의 IP 주소와 포트로 연결을 “요청(connect)”한다.
- 연결이 성립되면 두 프로세스는 소켓을 통해 데이터를 주고받는다.

즉 소켓은 개념적으로 다음과 같은 흐름으로 이해할 수 있다.

1. 서버가 포트를 열고 연결을 기다린다.
2. 클라이언트가 해당 포트로 연결을 시도한다.
3. 연결이 수립되면 양쪽 프로세스가 데이터를 송수신한다.

연결이 만들어진 이후에는 파이프(pipe)처럼 데이터를 주고받는 것처럼 보이지만, 실제로는 커널 네트워크 스택이 중간에서 패킷 송수신을 처리해준다.

파이프(pipe)는 기본적으로 단방향이라 양방향 통신에 2개의 파이프가 필요하지만, TCP 소켓은 연결이 수립되면 보통 양방향 송수신이 가능하다. 또한 소켓을 이용하면 로컬 IPC뿐 아니라 네트워크 통신까지 동일한 인터페이스로 처리가 가능하다.

그러나 데이터 전달이 커널 네트워크 스택을 통해 이루어지므로 오버헤드가 존재한다. 이에 더해 통신 과정에서 패킷(packet) 단위로 데이터가 송수신되며, 네트워크 환경에서는 지연(latency), 손실(loss) 등 다양한 변수가 존재한다.

---

## 2. 공유 메모리 방식 (Shared Memory Model)

공유 메모리(Shared Memory) 방식은 협력 프로세스들이 **공유 메모리 영역을 설정한 뒤**, 해당 메모리 공간을 통해 데이터를 읽고 쓰며 정보를 교환하는 IPC 방식이다.

프로세스는 원칙적으로 서로 독립적인 주소 공간을 가지므로(가상 메모리), 다른 프로세스의 메모리에 직접 접근할 수 없다. 하지만 운영체제는 공유 메모리를 위한 시스템 콜을 제공하여, 서로 다른 프로세스들이 **각자의 주소 공간 중 일부를 동일한 물리 메모리로 매핑(mapping)** 할 수 있게 해준다. 즉, **특정 메모리 영역만 서로 공유하도록 만드는 방식**이다.

<img width="245" height="327" alt="Shared Memory" src="https://github.com/user-attachments/assets/4762e8e5-32a3-453d-afb7-52318101a740" />

Shared Memory

공유 메모리 방식은 공유 영역을 생성하고 매핑하는 단계에서 시스템 콜이 필요하지만, 공유 메모리가 한 번 설정되면 그 이후 데이터 교환은 단순히 **메모리 읽기/쓰기(memory access)** 로 처리된다.

따라서 메시지 전달 방식(Message Passing)처럼 커널이 매번 데이터를 복사하거나 전달을 중재하지 않기 때문에, 일반적으로 **오버헤드가 적고 빠르게 동작**할 수 있다.

공유 메모리 방식은 빠르고 효율적인 IPC 방식이지만, 여러 프로세스가 동시에 같은 데이터를 읽고/수정할 수 있기 때문에 **경쟁 상태(Race Condition)** 와 같은 일관성 문제가 발생할 수 있다.

예를 들어 동시에 두 프로세스가 공유 변수 값을 수정하면 결과가 의도와 달라질 수 있다. 따라서 공유 메모리를 사용할 때는 반드시 동기화 메커니즘이 필요하며, 이를 위해 뮤텍스(mutex), 세마포어(semaphore) 등의 기법을 함께 사용한다.

---

## 그 외

### 메모리 맵(memory-mapped file, `mmap`)

공유 메모리(shared memory)와 마찬가지로 메모리 맵(memory-mapped file, `mmap`) 또한 **프로세스 간 메모리를 공유**할 수 있다는 점에서 비슷하다. 차이점은 공유 메모리는 별도의 공유 영역을 만들지만, **메모리 맵은 열린 파일을 프로세스의 가상 메모리 주소 공간에 매핑(mapping)** 하여 공유한다는 점이다.

즉 `mmap`은 “파일을 읽어서 버퍼에 복사하는 방식(read)”이 아니라, 파일의 내용을 **메모리처럼 접근 가능하게 만드는 방식**이다. 이러한 특성 때문에 주로 파일 기반으로 대용량 데이터를 다루거나, 반복적인 파일 접근으로 인해 I/O 오버헤드가 커지는 상황에서 유리할 수 있다.

다만 파일은 여러 프로세스가 접근할 수 있는 대표적인 공유 자원이기 때문에, 메모리 맵으로 파일 데이터를 공유하는 경우에도 **데이터 일관성 및 동기화 문제(경쟁 상태)** 가 발생할 수 있으며 적절한 동기화 설계가 필요하다.

또한 매핑된 상태에서 파일 크기를 변경(truncate)하는 것은 위험할 수 있으며, 특히 파일이 줄어든 경우 해당 영역 접근 시 SIGBUS와 같은 오류가 발생할 수 있다. 따라서 일반적으로 파일 크기 변경은 매핑 전/후에 수행하는 것이 안전하다.

### **시그널(Signal)**

시그널(signal)은 운영체제가 프로세스에 특정 이벤트가 발생했음을 알리기 위해 전달하는 **비동기 이벤트 알림 메커니즘**이다. 넓은 의미에서는 프로세스 간 이벤트/제어를 전달하기 때문에 IPC로 분류되기도 한다.

시그널은 외부에서 전달되는 비동기 이벤트(예: 종료 요청)로 발생할 수도 있고, 잘못된 메모리 접근과 같은 오류(fault)가 발생했을 때 커널이 프로세스에게 **동기적으로 전달**할 수도 있다.

특정 이벤트가 발생하면 커널이 시그널을 생성하여 대상 프로세스에게 전달한다. 프로세스는 시그널을 전달받으면 해당 시그널에 대응하는 처리를 수행하는데, 이때 시그널에 대한 처리 방식은 다음 중 하나로 결정된다.

- 커널에서 정의된 기본 동작(default action)을 수행한다. (예: 종료)
- 프로그래머가 등록한 시그널 핸들러(signal handler)를 실행한다.
- 특정 시그널은 무시(ignore)할 수도 있다. (단, SIGKILL 등 일부 시그널은 처리/무시 불가)

즉, 프로세스는 각 시그널에 대해 커널이 제공하는 기본 동작 대신, 직접 정의한 handler를 등록하여 시그널 처리 방식을 변경할 수 있다.

사진 출처 - operating system concepts essentials 2nd edition(공룡책)

---

## iOS 관점에서 정리: IPC 실제 앱 개발에서는 어떻게 연결될까?

운영체제의 IPC(Inter-Process Communication)는 프로세스 간 데이터를 주고받는 핵심 개념이지만, iOS 앱 개발에서는 일반적인 데스크톱 OS와는 다른 방식으로 “프로세스 협력”이 이루어진다.

iOS는 보안과 안정성을 최우선으로 하는 모바일 OS이며, 앱은 기본적으로 **샌드박스(Sandbox)** 환경에서 실행된다. 즉, 서드파티 앱은 서로의 프로세스나 파일 영역에 직접 접근할 수 없도록 설계되어 있으며, IPC는 운영체제가 허용하는 제한된 방식으로만 이루어진다.

그럼에도 불구하고 iOS에서 IPC가 중요해지는 순간이 있다. 바로 **App Extension**이다.

예를 들어 아래 기능들은 메인 앱과 분리된 실행 환경에서 동작할 수 있다.

- Share Extension
- Widget Extension
- Notification Service Extension
- Keyboard Extension 등

이때 Extension은 대부분 별도 프로세스로 실행되기 때문에 메인 앱과 데이터를 직접 공유할 수 없다. 이 경우 운영체제가 허용하는 방식으로만 데이터 공유/통신이 가능하다.

대표적으로 많이 사용되는 방식은 다음과 같다.

- **App Group**
    - `UserDefaults(suiteName:)`
    - 공용 컨테이너(shared container) 파일 저장
- URL Scheme / Universal Links 등으로 앱 호출 및 전달
- Darwin Notification 등 이벤트 트리거(간단한 알림 목적)

이에 더해 계속해서 작성하지만 iOS 앱 개발에서는 멀티 프로세스보다 멀티 스레드가 더 일반적이다. (멀티 스레딩 + 동기화에 대해 더 학습 하는 것이 도움이 될 것이다.)

# **정리**

|  | PIPE | Named PIPE | MQ | Shared Memory | Memory Map | Socket |
| --- | --- | --- | --- | --- | --- | --- |
| 사용시기 | 부모 자식 간 단방향 통신 시 | 다른 프로세스와 단방향 통신 시 | 다른 프로세스와 단방향 통신 시 | 다른 프로세스와 양방향 통신 시 | 다른 프로세스와 양방향 통신 시 | 다른 시스템 간 양방향 통신 시 |
| 공유매개체 | 파일 | 파일 | 메모리 | 메모리 | 파일+메모리 | 소켓 |
| 통신 단위 | Stream | Stream | 구조체 | 구조체 | 페이지 | Stream |
| 통신 방향 | 단방향 | 단방향 | 단방향 | 양방향 | 양방향 | 양방향 |
| 통신 가능 범위 | 동일 시스템 | 동일 시스템 | 동일 시스템 | 동일 시스템 | 동일 시스템 | 동일 + 외부 시스템 |
