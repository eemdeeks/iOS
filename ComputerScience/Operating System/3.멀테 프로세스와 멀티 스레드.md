# 멀티 프로세스(Multi-Process)와 멀티 스레드(Multi-Thread)
우리가 사용하는 앱은 사용자 입력 처리, 네트워크 통신, 화면 렌더링 등 여러 작업을 동시에 수행해야 한다.이때 운영체제는 멀티 프로세스/멀티 스레드 방식으로 작업을 분산 처리할 수 있게 해준다.

 **멀티 프로세스(Multi-Process)와 멀티 스레드(Multi-Thread)**는 하나의 프로그램이 여러 작업을 동시에 처리하기 위해 사용하는 대표적인 방식이다. 하지만 스레드나 프로세스를 늘리는 것이 항상 성능 향상으로 이어지는 것은 아니며, 안정성/메모리/관리 비용 측면에서 trade-off가 존재한다.

 이번 글에서는 멀티 프로세스와 멀티 스레드의 차이점과 각각의 장단점을 정리해보려고 한다.

# 멀티 프로세스(Multi Process)

 멀티 프로세스는 하나의 프로그램(또는 서비스)이 동시에 여러 개의 프로세스를 사용하여 작업을 처리하는 방식이다. 

 일반적으로 프로그램을 실행하면 하나의 프로세스(메모리)가 생성되지만, 안정성이나 역할 분리를 위해 여러 프로세스를 생성해 작업을 분리하기도 한다.

 멀티 프로세스 구조에서는 하나의 프로세스가 새로운 프로세스를 생성할 수 있으며, 이때 다른 프로세스를 생성하는 프로세스를 **부모 프로세스(Parent Process)**, 생성된 프로세스를 **자식 프로세스(Child Process)** 라고 한다. 프로세스는 실행 중 **프로세스 생성 시스템 콜**을 통해 새로운 프로세스를 생성할 수 있다.

시스템 콜에 대해서는 이 후에 자세히 학습 및 포스트 하겠다.

 부모 프로세스와 자식 프로세스는 각각 고유한 PID(Process ID)를 가지며, 자식 프로세스는 PPID(Parent Process ID)를 통해 자신의 부모 프로세스를 식별할 수 있다. 프로세스 간 통신은 PID를 이용한 **IPC(Inter Process Communication)** 같은 별도의 메커니즘을 통해 이루어진다.
 부모 프로세스와 자식 프로세스는 서로 다른 프로세스로 **독립적으로 실행**되며, 각각 **독립적인 메모리 주소 공간**을 가진다. 이 때문에 하나의 프로세스에 문제가 발생해도 다른 프로세스로 영향을 제한할 수 있다는 장점이 있다.

 대표적인 예로 크롬과 같은 웹 브라우저 탭(Tab)이 있다. 각 탭은 같은 브라우저 프로그램이지만, 하나의 탭이 문제를 일으켜도 전체 브라우저가 종료되는 것을 방지하기도 한다.

---

### iOS에서의 멀티 프로세스

 iOS 또한 멀티 프로세스 기반 운영체제이지만, 일반적인 서드파티 앱은 보통 1개의 프로세스로 실행된다. 그 이유는 iOS 철학인 아래와 같은 이유들 때문이다.

- 보안
- 배터리
- 메모리
- 백그라운드 제한

 그렇다면 언제 어떻게 멀티 프로세스로 사용할 수 있을까?

 개인적으로는 멀티 프로세스를 앱 내에서 직접 사용하는 방법은 찾지 못했다. (주로 멀티 스레드 사용. 이유는 아래에서 다루겠다.)

 다만 App Extension과 같은 기능은 시스템에 의해 호스트 앱과 별도의 프로세스로 실행이 된다.

→ 공식문서(App Extension)[https://developer.apple.com/documentation/technologyoverviews/app-extensions?utm_source=chatgpt.com]

---

## 멀티 프로세스의 장점

### 1. 안전성

 멀티 프로세스는 각 프로세스가 **독립적인 메모리 공간(주소 공간)** 을 갖는다. 따라서 한 프로세스가 비정상 종료되더라도 다른 프로세스에 영향을 주지 않아 전체 시스템 안정성이 높다는 장점이 있다.

### 2. 병렬성

 멀티 프로세스는 여러 개의 CPU 코어를 활용하여 각 프로세스를 병렬적으로 실행할 수 있다. 이를 통해 다중 코어 환경에서 전체 처리량(throughput)을 향상시킬 수 있다.

 다만 “병렬 실행” 자체는 멀티 스레드에서도 가능하므로 멀티 프로세스만의 장점이라고 보기는 어렵다. 대신 멀티 프로세스는 프로세스 간 메모리 격리를 통해 안정성을 유지한 채 병렬 처리를 구성할 수 있다는 점에서 큰 장점이 있다. 

> 멀티 프로세스보다 멀티 스레드로 구성하는 것이 대부분 효율적이고 빠르기 때문에, 멀티 프로세스로 성능을 올리는 경우는 거의 없다고 봐도 무방하다.
> 

### 3. 시스템 확장성

 멀티 프로세스는 각 프로세스가 독립적으로 실행되기 때문에 새로운 기능을 추가하거나 수정할 때 다른 기능에 대한 영향이 상대적으로 적다. 따라서 시스템을 확장하기에 유리하다.

 iOS에서는 대표적으로 **App Extension**이 이러한 구조를 활용한다. 위젯(Widget), 공유 확장(Share Extension), 알림 확장(Notification Service Extension) 등은 메인 앱과 **별도의 프로세스**로 실행되며, 메인 앱의 기능을 확장하는 방식으로 동작한다. 이를 통해 기능을 추가하더라도 메인 앱의 안정성을 유지할 수 있고, 특정 확장 기능에 문제가 생겨도 전체 앱에 영향을 최소화할 수 있다.

## 멀티 프로세스의 단점

### 1. Context Switching Overhead

 멀티태스킹을 구성하는 핵심 기술인 컨텍스트 스위칭(Context Switching) 과정에서 성능 저하가 발생할 수 있다. 특히 프로세스 단위의 컨텍스트 스위칭은 스레드보다 비용이 큰 편인데, 이는 실행 중이던 프로세스의 상태를 저장하고 다음 프로세스의 상태를 복원하는 과정이 필요하기 때문이다.

 또한 프로세스가 전환되면 메모리 접근 패턴이 달라져 **CPU 캐시 효율이 감소(캐시 미스 증가)** 할 수 있으며, 경우에 따라 **TLB 미스** 등으로 인해 추가적인 오버헤드가 발생할 수 있다. 이러한 이유로 빈번한 프로세스 컨텍스트 스위칭은 성능 저하를 유발한다.

 따라서, 멀티 프로세스 환경에서는 Context Switching Overhead를 최소화하는 방법이 중요하다. 불필요한 프로세스 생성을 줄이거나 프로세스 풀(pool)처럼 작업을 재사용하는 방식 등을 고려할 수 있다.

### 2. 자원 공유 비효율성

 멀티 프로세스는 각 프로세스가 독립적인 메모리 공간을 가지므로, 동일하거나 유사한 데이터를 각 프로세스가 별도로 유지하게 되어 **메모리 사용량이 증가**할 수 있다.
 또한 프로세스 간 자원 공유가 필요할 경우 **IPC(Inter-Process Communication)** 를 사용해야 한다. IPC란 운영체제 상에서 실행 중인 프로세스 간에 정보를 주고받기 위한 메커니즘이며, 파이프(pipe), 소켓(socket), 메시지 큐(message queue), 공유 메모리(shared memory) 등 다양한 방식이 존재한다.

 다만 IPC는 데이터 복사, 버퍼링, 동기화 등의 과정에서 오버헤드가 발생할 수 있고, 구현이 복잡해져 코드 유지보수 비용이 증가할 수 있다.

Context Switching, IPC에 관해서는 이 후에 좀 더 자세히 다루겠다.

# 멀티 스레드(Multi Thread)

 스레드(Thread)는 하나의 프로세스 내에서 실행되는 실행 흐름이다. 그리고 멀티 스레드(Multi-thread)는 하나의 프로세스 안에 여러 개의 스레드가 존재하여 여러 작업을 동시에 처리할 수 있는 구조를 의미한다. 이를 통해 하나의 프로그램에서 두 가지 이상의 동작을 동시에 수행할 수 있다.

 iOS 앱은 대부분 멀티 스레드를 적극적으로 활용한다. 예를 들어 사용자가 앱에서 화면을 스크롤하거나 버튼을 누르는 동안에도 네트워크 요청, 이미지 다운로드/디코딩, 파일 I/O 등의 작업이 함께 수행된다. 만약 이러한 작업들이 모두 메인 스레드(Main Thread)에서 수행된다면 UI가 멈추거나 끊기는 현상이 발생할 수 있다.

 따라서 iOS에서는 UI 업데이트와 사용자 입력 처리를 담당하는 메인 스레드와 별개로, 네트워크/데이터 처리 같은 시간이 오래 걸릴 수 있는 작업을 백그라운드 스레드에서 처리한다. 이를 통해 특정 작업이 지연되더라도 앱 전체가 멈추지 않고, 사용자는 계속 앱과 상호작용할 수 있게 된다.

---

### iOS에서의 멀티 스레드

 iOS는 다양한 동시성 API(GCD, OperationQueue, Swift Concurrency)를 제공하며, 이를 활용해 작업을 멀티 스레드로 분리할 수 있다.

 특히 메인 스레드는 UI 업데이트를 담당하므로, 무거운 작업은 메인 스레드를 점유하지 않도록 설계하는 것이 중요하다.

- Main Thread
    - iOS 앱은 기본적으로 **메인 스레드(Main Thread)** 를 중심으로 동작한다. 메인 스레드는 사용자의 터치 입력 처리, UI 이벤트 처리, 화면 렌더링 및 업데이트 등 사용자 인터페이스(UI)와 관련된 핵심 작업을 담당한다.
    - iOS에서 멀티 스레딩을 사용하는 목적은 단순히 “더 빠르게 실행하기 위함”이 아니라, 메인 스레드에서 UI가 끊기지 않도록 하고 사용자에게 좋은 반응성(Responsiveness)을 제공하기 위함이다.
- 스레드 관리 API
    - **GCD(Grand Central Dispatch)**
        
        iOS에서 가장 널리 사용되는 동시성 도구로, 개발자가 직접 스레드를 관리하기보다는 작업(Task)을 큐(Queue)에 등록하면 시스템이 적절한 스레드에 분배해 실행한다. 메인 큐(main queue)와 글로벌 큐(global queue)를 활용해 UI 작업과 백그라운드 작업을 분리할 수 있다.
        
    - **Operation Queue**
        
        GCD보다 조금 더 고수준의 추상화를 제공하며, 작업 간 의존성(dependency), 취소(cancellation), 우선순위(priority) 등 복잡한 작업 흐름을 구성할 때 유용하다.
        
    - **Swift Concurrency**
        
        async/await 기반으로 비동기 코드를 더 직관적으로 작성할 수 있게 해주는 방식이다. 개발자가 스레드 자체를 직접 다루기보다는, 구조화된 동시성(structured concurrency)을 통해 작업의 실행 흐름을 설계할 수 있으며, 안정적인 동시성 코드를 작성하기에 적합하다.
        

---

## 멀티 스레드의 장점

위에서 언급했듯 일반적으로 멀티 프로세스보다 멀티 스레드로 구현하는 경우가 많다. 그 이유는 멀티 스레드가 갖는 장점 때문이다.

### 1. 스레드는 프로세스보다 가벼움

 스레드는 프로세스보다 생성 및 종료에 필요한 **오버헤드가 작다.** 스레드는 프로세스 내부에서 생성되기 때문에 별도의 주소 공간을 새로 구성할 필요가 없으며, 실행 환경 설정이 상대적으로 단순하다.

 또한 스레드는 프로세스와 달리 **코드(Code), 데이터(Data), 힙(Heap) 등의 자원을 공유**하고, 각 스레드마다 **독립적인 스택(Stack)** 만을 가지므로 프로세스에 비해 관리해야 할 실행 상태가 상대적으로 작다. 따라서 스레드를 생성하고 제거하는 작업은 프로세스보다 빠르게 수행될 수 있다.

### 2. 자원의 효율성

 멀티 스레드는 하나의 프로세스 내에서 여러 스레드가 동작하므로, 힙 영역과 같은 공유 메모리를 통해 스레드 간 자원 공유가 가능하다. 이로 인해 프로세스 간 통신(IPC)을 사용하지 않고도 데이터를 공유할 수 있어 자원을 효율적으로 활용할 수 있고, 시스템 자원 소모를 줄일 수 있다.

### 3. Context Switching 비용 감소

 스레드에도 컨텍스트 스위칭(Context Switching) 오버헤드는 존재한다. 그러나 일반적으로 스레드 컨텍스트 스위칭은 프로세스 컨텍스트 스위칭보다 비용이 낮다.

 프로세스의 컨텍스트 스위칭에서는 서로 다른 주소 공간으로 전환되기 때문에 캐시 효율이 감소하거나 TLB 미스 등의 오버헤드가 발생할 수 있다. 반면 스레드 스위칭은 같은 주소 공간을 공유하므로, 주로 레지스터(register)와 스택(stack) 등 실행 상태만 교체하면 되어 상대적으로 비용이 적다.

### 4. 응답 시간 단축

 앞의 장점을 종합하면 멀티 스레드는 자원 공유가 용이하고, 생성/관리 오버헤드가 작으며, 컨텍스트 스위칭 비용도 상대적으로 낮다. 따라서 멀티 프로세스 방식보다 더 빠른 응답 시간을 제공할 수 있는 경우가 많다.

 iOS 앱에서는 네트워크 요청, 이미지 디코딩, 파일 I/O 같은 작업을 백그라운드 스레드에서 처리하고, 메인 스레드는 UI 업데이트를 담당하도록 분리함으로써 **사용자에게 끊김 없는 반응성을 제공**할 수 있다.

## 멀티 스레드의 단점

### 1. 안정성 문제

멀티 프로세스 모델에서는 각 프로세스가 독립적으로 동작하므로 하나의 프로세스에서 문제가 발생해도 다른 프로세스에 영향을 주지 않을 수 있다. 반면 멀티 스레드 모델에서는 여러 스레드가 동일한 프로세스의 자원을 공유하므로, 특정 스레드에서 문제가 발생했을 때 프로세스 전체 안정성에 영향을 줄 가능성이 크다.

따라서 멀티 스레드 환경에서는 적절한 예외 처리, 안전한 자원 접근, 스레드 생명주기 관리 등을 더욱 신중하게 설계해야 한다.

### 2. 동기화로 인한 성능 저하

 멀티 스레드 모델에서는 여러 스레드가 공유 자원(Heap/Data 등)에 동시에 접근할 수 있기 때문에 **경쟁 상태(Race Condition)** 가 발생할 수 있다. 예를 들어 여러 스레드가 동시에 같은 자원을 변경하면 의도하지 않은 결과가 발생하고 심각한 버그로 이어질 수 있다.

 이를 방지하기 위해 스레드 간 동기화(Synchronization)가 필요하며, 대표적으로 **임계 영역(Critical Section)** 을 보호하기 위해 뮤텍스(Mutex), 세마포어(Semaphore) 등을 사용한다.

 하지만 동기화는 접근을 제한하는 과정이 포함되므로 락 경합(lock contention)이나 병목이 발생할 수 있고, 결과적으로 성능 저하가 발생할 수 있다.

### 3. 데드락

데드락이란 여러 프로세스 또는 스레드가 서로 자원을 점유한 상태에서 상대가 점유한 자원을 기다리며 영원히 진행하지 못하는 교착 상태를 의미한다.

예를 들어,

- 스레드 1이 자원 A를 획득한 상태에서 자원 B를 기다리고
- 스레드 2가 자원 B를 획득한 상태에서 자원 A를 기다리면
    
    서로가 서로를 기다리며 무한 대기 상태에 빠질 수 있다.
    

데드락은 보통 다음 조건이 동시에 성립될 때 발생할 수 있다.

- 상호 배제(Mutual Exclusion)
- 점유와 대기(Hold and Wait)
- 비선점(No Preemption)
- 순환 대기(Circular Wait)

또한 데드락은 멀티 스레드에서만 발생하는 문제가 아니라, 멀티 프로세스 환경에서도 IPC 등으로 공유 자원을 사용할 경우 동일하게 발생할 수 있다.

데드락에 관해서는 이 후에 더 자세히 다루도록 하겠다.

### 4. Context Switching Overhead

 멀티 스레드는 프로세스보다 컨텍스트 스위칭 비용이 적은 편이지만, 컨텍스트 스위칭 오버헤드 자체가 없어지는 것은 아니다. 스레드 수가 지나치게 많아지면 컨텍스트 스위칭이 빈번해지고, 이는 성능 저하로 이어질 수 있다.

 즉, 스레드는 무조건 많을수록 성능이 좋아지는 것이 아니라, 오히려 적절한 수준으로 관리되어야 한다. 이 주제는 기술 면접에서도 자주 등장하는 질문 중 하나이며, 이후 컨텍스트 스위칭 파트에서 자세히 다루겠다.

### 5. 디버깅의 어려움

 멀티 스레드 환경에서는 여러 스레드가 동시에 실행되므로 실행 순서가 비결정적(non-deterministic)일 수 있다. 결국 각 스레드의 동작을 추적하기 어려울 수 있다. 이 때문에 버그가 특정 상황에서만 발생하거나, 재현이 어려워지는 문제가 생긴다. 

 따라서 스레드 간 상호작용과 동기화 기법에 대한 이해가 필요하며, 디버깅 도구와 로그 등을 활용해 실행 흐름을 분석하는 능력이 중요하다.
