# CPU 스케줄링(CPU Scheduling)
CPU 스케줄링(CPU Scheduling)이란 여러 프로세스(또는 스레드) 중 **어떤 작업에 CPU를 배정할지 결정하는 것**이다. 컴퓨터 시스템의 효율은 어떤 작업에 CPU를 먼저 배정하느냐에 따라 크게 달라지므로, CPU 스케줄링은 **시스템의 처리 효율성과 작업의 공정성**을 결정하는 중요한 기능이다.

운영체제의 스케줄링은 역할과 범위에 따라 **고수준(장기) 스케줄링, 중간 수준(중기) 스케줄링, 저수준(단기) 스케줄링** 으로 구분된다.

### 고수준 스케줄링 (High-level Scheduling, Long-term Scheduler)

고수준 스케줄링은 시스템에 들어오는 작업(job) 중에서 **어떤 작업을 받아들일지 또는 거부할지**를 결정한다. 이를 통해 시스템 내에서 동시에 실행 가능한 프로세스의 총 개수, 즉 **멀티프로그래밍 정도(degree of multiprogramming)** 를 조절한다.

### 중간 수준 스케줄링 (Mid-level Scheduling)

중간 수준 스케줄링은 고수준 스케줄링과 저수준 스케줄링 사이에서, 실행 중인 프로세스의 수를 조절하기 위한 스케줄링이다. 프로세스가 활성화된 이후에도 시스템에 과부하가 걸릴 수 있기 때문에, 일부 프로세스를 **중지(suspend)** 상태로 보내거나 다시 활성화(active)하여 **메모리에 올라간 활성 프로세스 수를 조정**한다. 이를 통해 시스템 과부하를 방지한다.

### 저수준 스케줄링 (Low-level Scheduling, Short-term Scheduler)

저수준 스케줄링은 준비 상태(ready)에 있는 프로세스(또는 스레드)들 중 **다음에 CPU에서 실행할 작업을 선택하는 스케줄링**이다. 즉, 실제로 CPU를 누구에게 배정할지를 결정하는 단계로, 일반적으로 우리가 말하는 **CPU 스케줄링은 이 단기(저수준) 스케줄링을 의미**한다.

## CPU 스케줄링의 목적

CPU 스케줄링은 준비 상태(Ready)에 있는 프로세스/스레드 중 누가 CPU를 사용할지 결정하는 과정이며, 스케줄링 정책은 다음 목적을 만족하도록 설계된다.

### 1. 공정성

모든 프로세스가 CPU 자원을 **편향 없이** 배정받도록 한다.

특정 프로세스만 계속 실행되거나, 반대로 특정 프로세스가 계속 밀리지 않도록 보장하는 것이 중요하다.

### 2. 효율성(Efficiency) / CPU 활용률 향상

CPU가 가능한 한 **유휴(idle) 상태가 되지 않도록** 한다.

특히 I/O 대기 중인 프로세스를 실행시키느라 CPU가 놀지 않도록, 실행 가능한 작업을 적절히 선택해 **CPU 이용률과 처리율을 높이는 것**이 핵심이다.

### 3. 반응성(Response Time)

사용자가 체감하는 시스템 성능을 위해, 입력(클릭/터치 등)에 대해 **빠르게 반응**할 수 있어야 한다.

따라서 인터랙티브 시스템(iOS/GUI 환경)에서는 처리량보다 **response time**이 더 중요한 목표가 되기도 한다.

### 4. 기아 상태 방지(Starvation Prevention) / 무한 연기 방지

우선순위가 낮거나 긴 작업이라도 **영원히 실행되지 않는 상황**(무한 연기)이 발생하면 안 된다.

이를 해결하기 위해 Aging(오래 기다리면 우선순위 상승) 같은 기법이 사용된다.

### 5. 우선순위 및 중요도 반영(Priority)

중요한 작업(예: UI 이벤트 처리, 시스템 서비스 등)은 더 빨리 실행되어야 한다.

따라서 스케줄링은 “무조건 공평”이 아니라, 상황에 따라 **우선순위 기반으로 차등 배정**이 가능해야 한다.

## 프로세스 상태

프로세스의 상태(process state)란, 프로세스가 생성되어 종료될 때까지 실행 흐름에 따라 계속 변화하는 상태를 의미한다. 운영체제는 프로세스를 관리하기 위해 상태를 구분하며, 상태 변화에 따라 스케줄링 및 자원 할당을 수행한다.

프로세스는 일반적으로 **5가지 상태(5-state process model)** 를 가진다.

- **생성(New)**: 프로세스가 생성되었지만 아직 실행 준비가 완료되지 않은 상태
- **준비(Ready)**: CPU를 할당받으면 즉시 실행 가능한 상태. 실행을 위해 CPU를 기다리는 상태
- **실행(Running)**: CPU를 할당받아 명령어를 수행 중인 상태
- **대기(Waiting / Blocked)**: I/O 요청 등 특정 이벤트가 발생하여 완료되기를 기다리는 상태. CPU를 할당받아도 바로 실행할 수 없으며, 이벤트가 완료되면 다시 Ready 상태로 전환된다.
- **종료(Terminated)**: 실행이 완료되어 종료된 상태. 운영체제가 자원을 회수하고 종료 상태를 정리한 후 프로세스는 시스템에서 제거된다.

## 프로세스 상태 전이

프로세스 상태 전이(Process State Transition)란 프로세스가 실행되는 동안 **Ready, Running, Waiting 등의 상태가 변화하는 것**을 의미한다. 운영체제는 프로세스의 상태를 관리하며, 상태 전이는 스케줄링 결정 또는 이벤트(인터럽트, I/O 요청/완료 등)에 의해 발생한다.

예를 들어 운영체제는 Ready 상태에 있는 여러 프로세스 중 하나를 선택해 CPU를 할당함으로써 **Running 상태로 전환(dispatch)** 시킬 수 있다. 반대로 타이머 인터럽트가 발생하거나 우선순위가 높은 작업이 들어오면, 현재 실행 중인 프로세스를 다시 Ready 상태로 돌려보내는 **선점(preemption)** 이 일어날 수 있다. 또한 실행 중인 프로세스가 I/O 작업을 요청하면 **Waiting 상태로 전환**되고, I/O가 완료되면 다시 Ready 상태로 돌아와 CPU 할당을 기다린다.

즉, 운영체제는 프로세스 상태 전이를 기반으로 CPU 자원을 배분하고, 프로세스 실행 흐름을 제어한다.

<img width="519" height="218" alt="Diagram of process state." src="https://github.com/user-attachments/assets/2288a854-3915-479e-8299-c8f0ee7a0d35" />

Diagram of process state.

- **Admitted (new → ready)**: 프로세스 생성이 완료되고 시스템이 이를 받아들여 **Ready Queue에 등록**됨
- **Scheduler Dispatch (ready → running)**: 준비 상태의 프로세스 중 하나가 CPU를 할당받아 실행 상태로 전환됨
- **Interrupt (running → ready)**: 타이머 인터럽트(time quantum 만료) 또는 더 높은 우선순위 프로세스 등장으로 인해, 실행 중이던 프로세스가 CPU를 반납하고 다시 준비 상태로 전환됨
- **I/O or event wait (running → waiting)**: 실행 중인 프로세스가 I/O 요청이나 특정 이벤트를 기다려야 하므로 대기 상태로 전환됨
- **I/O or event completion (waiting → ready)**: I/O 작업 또는 이벤트 처리가 완료되어 프로세스가 다시 실행 가능한 준비 상태로 전환됨

## 프로세스 상태의 다중 큐 (Multiple Queues)

운영체제는 프로세스를 관리하기 위해 PCB(Process Control Block)를 유지하며, 각 프로세스의 우선순위나 상태 정보 또한 PCB에 포함된다. CPU 스케줄링 과정에서 중요한 것은 “실행 가능한 프로세스 중 어떤 것을 선택할지”인데, 만약 시스템 내 모든 PCB를 매번 탐색해 다음 실행 대상을 결정한다면 비효율적이다.

따라서 운영체제는 프로세스들을 상태에 따라 여러 큐로 나누어 관리하며, 특히 Ready 상태 프로세스들을 효율적으로 선택하기 위해 **다중 큐(Multiple Queue)** 구조를 사용한다.

<img width="549" height="490" alt="The ready queue and various I/O device queues." src="https://github.com/user-attachments/assets/5ffee287-4c87-446d-93c9-46e3b41a33da" />

The ready queue and various I/O device queues.

### 준비 상태(Ready)의 다중 큐

Ready 상태의 프로세스들은 보통 Ready Queue에 모여 관리된다. 만약 우선순위 기반 스케줄링을 사용하는 경우, Ready Queue를 **우선순위별로 여러 개로 분리**해 관리할 수 있다.

예를 들어 우선순위가 높은 프로세스는 높은 우선순위 큐에 넣고, 낮은 프로세스는 낮은 큐에 넣으면 CPU 스케줄러는 매번 모든 프로세스를 탐색하지 않아도 **가장 높은 우선순위 큐에서 바로 실행 대상을 선택**할 수 있다.

또한 프로세스 우선순위를 부여하는 방식에는 다음이 있다.

- **고정 우선순위(Fixed Priority)**: 우선순위가 프로세스 수명 동안 변하지 않음
- **변동 우선순위(Dynamic Priority)**: 실행 과정에서 우선순위가 변할 수 있음 (예: aging, MLFQ 등)

### 대기 상태(Waiting)의 다중 큐

Waiting 상태(또는 blocked 상태)의 프로세스는 보통 I/O 완료 등의 이벤트를 기다리며, 디스크/네트워크 등 장치 종류에 따라 **여러 개의 device queue(I/O device queues)** 로 나뉘어 대기할 수 있다.

I/O 작업이 완료되면 해당 장치에서 인터럽트가 발생하고, 운영체제는 인터럽트 벡터(인터럽트 번호에 따른 ISR 주소 테이블)를 통해 적절한 인터럽트 처리 루틴을 수행한 뒤, 해당 프로세스를 다시 Ready 상태로 전환하여 Ready Queue로 이동시킨다.

대기 큐의 처리 순서는 기본적으로 FIFO 형태일 수 있지만, 디스크 스케줄링과 같이 장치의 효율을 높이기 위한 정책에 따라 I/O 요청 처리 순서가 달라질 수 있으며, 결과적으로 나중에 요청된 작업이 먼저 완료되는 경우도 발생할 수 있다.

## 스레드 스케줄링(Thread Scheduling)

프로세스 스케줄링과 마찬가지로 **스레드 스케줄링(Thread Scheduling)** 은 운영체제가 여러 스레드 중에서 CPU를 사용할 실행 단위를 선택하고 CPU를 할당하는 과정을 의미한다. 현대 운영체제에서는 보통 프로세스 자체보다 **커널 스레드(kernel thread)** 가 실제 스케줄링 단위가 된다.

운영체제는 스레드의 우선순위(priority), 실행 시간(time quantum), I/O 요청 여부 등을 고려해 다음에 실행할 스레드를 선택하며, Round Robin, Priority Scheduling, Multilevel Queue(또는 MLFQ) 등의 방식이 사용된다.

다만 스레드는 같은 프로세스 내부에서 코드/data/heap과 같은 자원을 공유하기 때문에, 프로세스 간 스케줄링보다 **동기화(synchronization)** 및 **경쟁 상태(race condition)** 문제가 더 자주 발생하며 이를 고려한 설계가 필요하다.

> iOS에서는 개발자가 직접 스레드 스케줄링을 구현하기보다는, GCD/OperationQueue/Swift Concurrency에 작업을 위임하고 QoS(우선순위)를 조절하는 방식으로 스케줄링에 간접적으로 참여한다.
> 

### 스레드 상태(Thread State)

스레드의 상태는 운영체제나 구현 방식에 따라 다소 차이가 있지만, 일반적으로 다음과 같은 상태로 구분할 수 있다.

- **New**: 스레드가 생성된 상태 (아직 실행되지 않음)
- **Ready (Runnable)**: CPU를 할당받으면 즉시 실행 가능한 상태
- **Running**: CPU를 할당받아 실제로 실행 중인 상태
- **Blocked / Waiting**: I/O 완료, lock 획득, 이벤트 발생 등을 기다리며 실행할 수 없는 상태
- **Terminated**: 실행을 완료하고 종료된 상태

## 프로세스 우선순위(Priority)

프로세스(또는 스레드)의 우선순위가 높다는 것은 운영체제가 해당 작업을 더 자주, 더 빨리 실행하도록 CPU 할당에서 우선권을 준다는 의미이다. 운영체제는 시스템 효율성과 사용자 체감 성능을 높이기 위해 프로세스의 성격에 따라 우선순위를 다르게 부여한다.

### 1. 시스템 작업(커널/시스템 프로세스)

운영체제는 하드웨어 제어, 메모리 관리, 네트워크 처리 등 시스템 안정성과 직결되는 작업을 수행한다. 이러한 커널/시스템 작업은 사용자 앱보다 중요한 경우가 많으므로 일반적으로 더 높은 우선순위를 갖는다.

### 2. CPU 집중 작업 vs I/O 집중 작업

프로세스는 CPU 연산 중심(CPU-bound) 또는 입출력 중심(I/O-bound)으로 구분할 수 있다.

I/O-bound 작업은 CPU를 오래 점유하지 않고 빠르게 I/O를 요청한 뒤 waiting 상태로 전환되기 때문에, 먼저 실행되면 전체 시스템 관점에서 CPU 유휴 시간을 줄이고 효율을 높이는 효과가 있다. 따라서 운영체제는 I/O-bound 작업을 상대적으로 우선 처리하여 시스템 처리량과 응답성을 향상시킨다.

### 3. 전면 작업(Foreground) vs 후면 작업(Background)

전면 작업은 사용자 입력과 직접 상호작용하는 프로세스로, 빠른 응답이 중요하다. 반면 후면 작업은 사용자와 상호작용하지 않는 배치성 작업이므로 즉각적인 응답이 덜 중요하다. 따라서 운영체제는 전면 작업에 더 높은 우선순위를 부여하는 경우가 많다.

## 스케줄링 알고리즘

스케줄링 알고리즘은 여러 종류가 있으며, 어떤 알고리즘이 더 좋은지는 “무엇을 우선 가치로 두느냐”에 따라 달라진다. 알고리즘 성능 비교에는 **평균 대기 시간(Waiting Time)**, **반환 시간(Turnaround Time)** 등이 자주 사용되며, 인터랙티브 시스템에서는 **응답 시간(Response Time)** 이 특히 중요한 기준이 된다.

- **처리량(Throughput)**: 단위 시간당 처리 가능한 작업 수
- **반응 시간(Response Time)**: 요청 후 첫 응답까지 걸리는 시간
- **대기 시간(Waiting Time)**: Ready Queue에서 CPU 할당을 기다리는 시간
- **반환 시간(Turnaround Time)**: 작업 제출부터 완료까지 걸리는 전체 시간

상황에 따라 어떤 기준이 더 중요한지가 달라지므로, 시스템 목적에 맞는 알고리즘을 선택하는 것이 중요하다.

## 선점형 스케줄링과 비선점형 스케줄링

운영체제에서 선점(preemption)은 **실행 중인 작업으로부터 CPU를 “빼앗을 수 있는지”** 여부를 의미한다. 따라서 **선점형 스케줄링(Preemptive Scheduling)** 은 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 회수하여 다른 프로세스에게 할당할 수 있는 방식이다. 반대로 **비선점형 스케줄링(Non-preemptive Scheduling)** 은 한 프로세스가 CPU를 점유하면 **자발적으로 CPU를 반납할 때까지** 다른 프로세스가 이를 빼앗을 수 없는 방식이다.

선점형 스케줄링은 주로 **타이머 인터럽트(time quantum 만료)** 또는 더 높은 우선순위 프로세스의 등장과 같은 상황에서 발생하며, 응답성을 높여 시분할 시스템에 적합하다. 반면 비선점형 스케줄링은 프로세스가 종료되거나 I/O 요청으로 대기 상태에 들어가기 전까지 CPU를 점유하므로 구현은 단순하지만 응답성이 떨어질 수 있어 과거의 일괄 처리(batch) 시스템에서 주로 사용되었다.
