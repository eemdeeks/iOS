# 페이지 교체 알고리즘 (Page Replacement Algorithm)
페이징과 세그먼테이션을 학습하면서 가상메모리가 **요구 페이지 기법(Demand Paging)**을 사용한다는 것을 알게 되었다.

요구 페이지 기법이란, 프로세스가 **실제로 접근하는 페이지만 메모리에 적재**하고 나머지는 디스크에 그대로 두는 방식이다.

이 덕분에 메모리를 효율적으로 사용할 수 있지만, 프로그램이 실행되다 보면 결국 메모리는 가득 차게 된다.

> 페이지 부재(Page Fault)가 발생하면 새로운 페이지를 메모리에 적재해야 한다.
> 
> 
> 하지만 메모리가 이미 가득 차 있다면, 기존 페이지 중 하나를 교체해야 한다.
> 

이때 메모리에 올라와 있는 페이지는 아래 두가지가 있다.

- 더 이상 사용되지 않는 페이지
- 곧 다시 사용될 페이지

따라서 새로운 페이지를 가져오기 위해서는 **현재 메모리에 있는 페이지 중 하나를 내보내야(out)** 한다. 이때 교체 대상으로 선택되는 페이지를 **victim page**라고 한다.

기왕이면 **수정되지 않은 페이지를 선택하는 것이 유리하다.**

> 수정된 페이지는 디스크에 다시 기록(write-back)해야 하기 때문에
> 
> 
> 교체 비용이 더 크기 때문이다.
> 

이처럼 **페이지 부재 상황에서 어떤 페이지를 교체할지 결정하는 전략**이

바로 **페이지 교체 알고리즘(Page Replacement Algorithm)**이다.

### **Page Reference String**

CPU는 논리 주소를 통해 메모리 접근을 요청한다. 하지만 운영체제는 메모리를 **페이지 단위**로 관리하므로, 실제로 페이지 교체 알고리즘이 관심을 가지는 것은 **주소가 아니라 페이지 번호**이다.

프로그램 실행 중에는 같은 페이지에 속한 주소들이 연속해서 참조되는 경우가 많다. 이러한 경우, **같은 페이지에 대한 반복적인 참조는 하나의 참조로 간주**할 수 있다.

이처럼 CPU의 메모리 접근 중 **연속적으로 참조되는 동일한 페이지를 하나로 압축하여 나열한 것**이

바로 **Page Reference String**이다.

Page Reference String은 페이지 교체 알고리즘(FIFO, OPT, LRU 등)을 설명할 때 페이지 부재 발생 여부를 판단하기 위한 입력으로 사용된다.

## FIFO 페이지 교체 알고리즘 (First In First Out)

<img width="600" height="169" alt="FIFO page-replacement algorithm." src="https://github.com/user-attachments/assets/dee5f0e2-c8e0-4891-b40f-1acea72858c0" />

FIFO 페이지 교체 알고리즘은 **물리 메모리에 가장 먼저 적재된 페이지를 교체 대상(victim page)으로 선정**하는 방식이다.

즉, 페이지가 **들어온 순서**만을 기준으로 하여 가장 오래전에 메모리에 올라온 페이지를 스왑 아웃(swap out)한다.

이 알고리즘은 구현이 매우 단순하다는 장점이 있으며, 큐(Queue) 자료구조를 사용해 쉽게 구현할 수 있다.

특히 **초기화 코드**와 같은 경우에 비교적 적절하게 사용될 수 있다.

> **`초기화 코드` :** 프로세스가 처음 실행될 때 한 번만 사용되어 필요한 초기 설정을 수행한 뒤, 이후에는 다시 참조되지 않는 코드
> 

초기화 코드는 **프로세스 시작 시에는 반드시 필요하지만**, 초기화가 끝난 이후에는 더 이상 사용되지 않는 경우가 많다. 따라서 FIFO 알고리즘을 적용하면 초기화가 끝난 후 **가장 먼저 메모리에서 제거되는 페이지**가 될 가능성이 높아 이러한 특성과 잘 맞는 경우가 있다.

하지만 FIFO 알고리즘은 **페이지의 실제 사용 빈도나 재사용 가능성을 고려하지 않기 때문에**, 자주 사용되는 페이지가 단순히 오래되었다는 이유로 교체되는 문제가 발생할 수 있다.

## 최적 페이지 교체 알고리즘 (Optimal Page Replacement)

<img width="592" height="169" alt="Optimal page-replacement algorithm." src="https://github.com/user-attachments/assets/952cbfec-a1b6-47e0-b296-09b507e595c7" />

최적 페이지 교체 알고리즘은 **앞으로 사용할 페이지의 접근 순서를 모두 알고 있다는 가정 하에**, 페이지 교체 시점으로부터 **가장 나중에 다시 사용될 페이지**를 교체 대상으로 선택한다.

> 앞으로 가장 오랫동안 사용되지 않을 페이지 또는 다시 사용되지 않을 가능성이 가장 높은 페이지를 victim page로 선정한다.
> 

이 방식은 이론적으로 **페이지 결함(Page Fault)의 횟수를 최소화**할 수 있으며, 모든 페이지 교체 알고리즘 중에서 **가장 성능이 좋다**고 알려져 있다.

FIFO 알고리즘과 비교하면 불필요한 페이지 교체를 줄일 수 있기 때문에 페이지 결함 발생 횟수를 크게 감소시킬 수 있다.

하지만 이 알고리즘은 **치명적인 한계**를 가진다.

> 실제 실행 시점에서는
> 
> 
> 앞으로 어떤 페이지가 언제 다시 사용될지 **미리 알 수 없기 때문**이다.
> 

즉, 미래의 메모리 접근 패턴을 완벽하게 예측할 수 없으므로 **현실적인 시스템에서는 구현이 불가능한 이상적인 알고리즘**이다.

이 때문에 최적 페이지 교체 알고리즘은 실제 운영체제에서 사용되기보다는, 다른 페이지 교체 알고리즘들의 **성능 비교 기준(Benchmark)**으로 사용되며 이후 등장하는 알고리즘들(LRU 등)은

**이 최적 알고리즘에 최대한 근접하기 위한 시도**라고 볼 수 있다.

## LRU 페이지 교체 알고리즘(Least Recently Used)

<img width="592" height="169" alt="LRU page-replacement algorithm." src="https://github.com/user-attachments/assets/0e689993-f8c6-485b-9f70-f70d48bbe56a" />

메모리에 올라온 이후 **가장 오랫동안 사용되지 않은 페이지**를 교체하는 알고리즘이다.

OPT가 미래의 접근을 기반으로 한다면, LRU는 **과거의 사용 기록을 바탕으로 판단**하므로 실제로 구현 가능한 알고리즘이다.

일반적으로 최근에 사용하지 않은 페이지는 앞으로도 사용하지 않을 가능성이 높기 때문에 **실제 시스템에서 사용 가능한 페이지 교체 알고리즘 중 가장 효과적인 방법 중 하나**로 평가된다.

다만, 페이지 사용 기록을 유지해야 하므로 **추가적인 메모리 및 관리 비용이 발생**한다는 단점이 있다.

### LRU 구현 방식

LRU는 페이지의 사용 이력을 판단하는 방식에 따라 여러 구현 방법이 존재한다.

- **페이지 접근 시간에 기반한 구현**
- **카운터(접근 순서)를 기록하는 방식**
- **참조 비트를 이용해 최근 사용 여부를 판단하는 방식**

이러한 방식들은 모두 추가적인 메모리를 필요로 하며, 실제 운영체제에서는 **LRU를 완전히 구현하기보다는 근사 알고리즘**을 사용하는 경우가 많다.

## LFU 페이지 교체 알고리즘 (Least Frequently Used)

페이지가 **참조된 횟수(빈도)**를 기준으로 **가장 적게 사용된 페이지**를 교체하는 알고리즘이다.

자주 사용되는 페이지는 앞으로도 사용할 가능성이 높다는 가정을 기반으로 한다. 

장기간 사용 패턴을 잘 반영한다.

한 번 많이 사용된 페이지가 **계속 메모리에 남는 문제**가 발생할 수 있으며, 오래전에 집중적으로 사용된 페이지가 남아 있을 수 있게 된다.

## NUR 페이지 교체 알고리즘 (Not Used Recently)

페이지의 **최근 사용 여부**를 간단한 비트로 구분하여 최근에 사용되지 않은 페이지를 교체하는 알고리즘이다.

각 페이지는 보통 아래 두 비트를 갖는다.

- 참조 비트 (R): 최근에 접근되었는지
- 변경 비트 (M): 수정되었는지

페이지 교체 시, (R, M) 조합에 따라 **우선순위가 가장 낮은 페이지**를 선택한다.

## FIFO 변형 알고리즘

FIFO의 단순함을 유지하면서 **불필요한 페이지 교체를 줄이기 위해 개선한 방식**들이다.

### Second Chance 알고리즘

FIFO 기반이지만, 교체 대상 페이지가 **최근에 사용되었으면 한 번 더 기회를 주는 방식**이다.

각 페이지는 참조 비트를 가지며, 참조 비트가 1이면 교체하지 않고 0으로 초기화 한 뒤 큐의 뒤로 이동시킨다. 만약 0이라면 교체 대상으로 결정된다.

### Clock 알고리즘

Second Chance를 **원형 큐(시계 모양)**로 구현한 알고리즘이다.

포인터가 시계 방향으로 이동하며, 참조 비트가 1이면 0으로 바꾸고 넘어가고 참조 비트가 0인 페이지를 교체한다.

## 페이지 교체 방식

다중 프로그래밍 환경에서는 여러 프로세스가 동시에 메인 메모리에 올라가며, 각 프로세스의 페이지들이 함께 메모리를 구성한다. 이러한 상황에서 페이지 교체가 필요할 때, **victim page를 어떤 범위에서 선택할 것인지**에 따라

페이지 교체 방식은 다음 두 가지로 나뉜다.

### Global 페이지 교체

페이지 교체 시, **메인 메모리에 존재하는 모든 프로세스의 페이지를 대상으로** victim page를 선정하는 방식이다. 즉, 현재 실행 중인 프로세스의 페이지뿐만 아니라 다른 프로세스의 페이지도 교체 대상이 될 수 있다.

- 메모리 전체를 기준으로 교체하므로 **유연한 메모리 사용 가능**
- 전체 시스템 관점에서 **페이지 결함 수를 줄이기 쉬움**
- 실제 운영체제에서 **주로 사용되는 방식**

### Local 페이지 교체

페이지 교체 시, **현재 실행 중인 프로세스에 할당된 페이지 내에서만** victim page를 선정하는 방식이다. 다른 프로세스의 페이지는 교체 대상에 포함되지 않는다.

- 각 프로세스의 메모리 사용량을 일정하게 유지 가능
- 특정 프로세스가 다른 프로세스의 성능에 영향을 덜 줌
- 전체 시스템 관점에서는 **비효율적일 수 있음**

### Global 교체가 더 많이 사용되는 이유

Local 교체 방식에서는 각 프로세스가 자신의 페이지 범위 내에서만 교체를 수행해야 하므로, 메모리 활용도가 낮아지고 프로세스마다 **불필요한 페이지 교체가 반복적으로 발생**할 수 있다. 반면 Global 교체는 메모리 전체를 기준으로 가장 적절한 페이지를 선택할 수 있어 **시스템 전체 성능과 메모리 활용 측면에서 더 효율적**이다.

---

## iOS 개발자로서 알면 좋은 것들

iOS 개발자는 페이지 교체 알고리즘을 직접 구현하지는 않지만, **앱의 메모리 동작을 이해하는 기반 개념**으로 중요하다.

페이지 교체 알고리즘은 OS가 **메모리가 부족할 때 어떤 메모리를 회수할지 결정하는 기준**이다.

이 개념을 알고 있으면 다음 상황을 이해하기 쉬워진다.

- 앱이 갑자기 종료되는 이유
- 메모리 경고가 발생하는 원인
- 특정 화면에서만 성능이 저하되는 현상

iOS는 기본적으로 **시스템 전체 메모리를 기준으로 관리하는 Global 관점**을 사용한다.

- 여러 앱이 동시에 메모리에 존재
- 시스템 메모리 압박 상황에 따라 특정 앱의 메모리가 회수되거나 앱이 종료될 수 있음

이때 중요한 점은 **내 앱의 메모리만 고려해서 판단하지 않는다는 것**이다. 그렇기 때문에 언제든 메모리를 회수당할 수 있음을 가정하고, 다시 생성 가능한 구조로 설계하는 것이 중요하다.

### iOS에서의 Thrashing

**Thrashing**은 페이지 교체가 지나치게 자주 발생하여 **실제 작업보다 메모리 교체에 더 많은 시간이 쓰이는 상태**를 의미한다.

iOS 앱에서 Thrasing은 아래와 같은 형태로 나타날 수 있다.

- 스크롤 시 프레임 드랍 발생
- 이미지가 반복적으로 로딩됨
- 화면 전환이 눈에 띄게 느려짐

이러한 형태들의 주요 원인은 과도한 객체 생성과 해제, 재사용되지 않는 뷰, 큰 리소스(이미지등)를 반복적으로 로드하는 경우이다.
