# 경쟁 상태(Race Condition)
경쟁 상태란 **공유 자원에 대해 여러 프로세스 또는 스레드가 동시에 접근할 때**, **실행 타이밍이나 순서에 따라 결과가 달라질 수 있는 상태**를 의미한다.

> 공유 자원에 여러 프로세스가 동시에 접근할 때 **자료의 일관성을 해치는 결과**가 나타날 수 있다.
> 

## 임계 구역 (Critical Section, 임계 영역)

경쟁 상태를 이해하기 위해 반드시 알아야 할 개념이 **임계 구역(Critical Section)** 이다.

> **임계 구역(Critical Section)** 이란 
운영체제에서 여러 프로세스 또는 스레드가 **동시에 접근해서는 안 되는 코드 영역**을 의미한다.
> 
> 
> 주로 공유 자원(shared resource)에 접근하거나 수정하는 코드로 구성되며, 동시 실행 시 잘못된 동작이나 데이터 일관성 문제를 방지하기 위해 보호되어야 한다.
> 

다시 말해 임계 구역이란 공유 자원에 접근하거나 수정하는 코드 영역을 말한다.

프로세스나 스레드가 공유 자원에 접근할 때 **동시에 접근하지 않도록 공유 자원의 독점을 보장해야 하는 영역**이 바로 임계 구역이다.

### 임계 구역의 주요 요구 사항

임계 구역을 올바르게 구현하기 위해서는 다음 세 가지 조건을 반드시 만족해야 한다.

- **상호 배제 (Mutual Exclusion)**
    - 한 번에 **하나의 프로세스/스레드만** 임계 구역에 진입할 수 있어야 한다. 다른 프로세스/스레드는 해당 영역을 빠져나올 때까지 기다려야한다.
- **진행 조건 (Progress)**
    - 임계 구역에 **아무도 진입해 있지 않다면**, 임계 구역에 진입하려는 프로세스/스레드 중 하나는 반드시 진입할 수 있어야 한다.
    - **임계 구역에 아무도 진입하지 못하면 안되며** 다음으로 임계 구역에 들어갈 프로세스/스레드의 선택은 **유한한 시간 안에 결정되어야 한다.**
- **유한 대기 (Bounded Waiting)**
    - 어떤 프로세스/스레드도 임계 구역에 진입하기 위해 **무한정 기다려서는 안 된다.**
    - 즉, **기아 상태(Starvation)** 가 발생하지 않아야 한다.

### 임계 구역에서 발생할 수 있는 문제

- 경쟁 상태 (Race Condition): 여러 프로세스/스레드가 동시에 임계 구역에 접근하여 공유 자원을 수정할 경우에 발생하는 일관성 문제
- 교착 상태 (Deadlock): 두 개 이상의 프로세스/스레드가 서로가 점유한 임계 구역(또는 락)을 서로가 기다리며 무한 대기에 빠지는 상태
- 기아 상태 (Starvation): 특정 프로세스/스레드가 임계 구역에 진입하지 못하고 무한정 대기에 빠지는 상태

## **경쟁 상태 (Race Condition)가 발생하는 경우**

1. **커널 작업을 수행하는 중에 인터럽트 발생하는 경우**
    - 문제점
        - 커널모드에서 데이터를 로드하여 작업을 수행하던 중 인터럽트가 발생하여 같은 커널 데이터를 조작하는 경우
        - 커널이 가진 전역 변수는 모든 프로세스의 공유물이므로 경쟁상태 발생 가능
    - 해결법
        - 커널 모드에서 임계 구역을 실행하는 동안 **인터럽트를 비활성화(disable)** 하여 CPU 제어권을 빼앗기지 않도록 한다.
2. **시스템 콜(System Call)을 처리 하기 위해 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환(Switching context)이 발생하는 경우**
    - 문제점
        - 프로세스가 시스템 콜로 커널 모드에 진입해 공유 커널 데이터를 수정하는 도중 **선점(preemption)** 이 발생하여 다른 프로세스가 동일한 데이터를 수정하는 경우
        - 이 경우, 이전 프로세스의 변경 사항이 반영되지 않아 데이터 불일치가 발생할 수 있다.
    - 해결법
        - 커널 모드에서 공유 데이터를 조작하는 동안 **선점되지 않도록 보호한다.**
        - 또는 커널 내부에서 **락(lock)** 을 사용하여 동기화한다.
3. **멀티 프로세서 환경에서 커널 데이터에 접근하는 경우**
    - 문제점
        - 멀티 코어 환경에서 두 개 이상의 CPU가 동시에 커널의 공유 데이터에 접근하여 수정하는 경우
    - 해결법
        - 커널 내부의 각 공유 데이터에 접근할 때마다, **lock/unlock**을 사용 하는 방법
4. **멀티 스레드 환경에서 사용자 공간의 공유 자원 접근하는 경우 (유저 레벨)**
    - 문제점
        - 여러 스레드가 동일한 변수, 객체, 컬렉션을 동시에 수정하는 경우
        - 실행 순서에 따라 결과가 달라지는 일관성 문제가 생길 수 있다.
    - 해결 방법
        - Mutex / Lock 사용
            - 세마포어와 뮤텍스 글에서 더 자세히 다룰 예정이다.
        - iOS 관점에서
            - Serial Queue 사용
            - Actor (Swift Concurrency) 사용

---

## iOS 개발자 관점에서 알면 좋을 것들

iOS 개발을 하다 보면 기본적으로 **멀티 스레드 환경**, **비동기 처리**, **동시성 프로그래밍**을 피할 수 없다.

GCD, OperationQueue, Swift Concurrency(Task, async/await, Actor) 등 편리한 도구들이 제공되지만, 그 내부에서는 여전히 **운영체제의 스케줄링과 동기화 원리**가 그대로 적용된다.

이 때문에 동시성 프로그래밍에서는 다음과 같은 **동시성 문제(Concurrency Issues)** 들이 자주 발생한다.

### 동시성 문제 (Concurrency Issues)

- 경쟁 상태
- 경쟁 상태 (Race Condition)
- 데드락 (Deadlock)
- 라이브락 (Livelock)
- 기아 상태 (Starvation)
- 우선순위 역전 (Priority Inversion)

### 놓치면 안되는 이유

동시성 문제들은 단순한 이론에 그치지 않고, 실제 앱에서는 다음과 같은 형태로 나타난다.

- 앱이 멈춘다.
- UI 반응이 눈에 띄게 느려진다.
- 특정 조건에서만 재현되는 버그가 발생한다.
- 디버깅이 매우 어렵다.

이러한 문제들의 공통점은 **코드만 봤을 때는 정상처럼 보이지만**, 동시성 프로그래밍 환경에서는 **런타임에 갑자기 터진다**는 점이다.

즉, GCD나 Swift Concurrency 문법을 안다고 해서 동시성 문제가 자동으로 해결되지는 않는다.

> 결국 중요한 것은 
**임계 구역을 어떻게 보호할 것인가**, 
**공유 상태를 어떻게 설계할 것인가**, 
**스케줄링과 우선순위를 어떻게 이해하고 사용할 것인가**이다.
>
