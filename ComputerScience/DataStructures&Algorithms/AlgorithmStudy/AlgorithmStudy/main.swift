//
//  main.swift
//  AlgorithmStudy
//
//  Created by 박승찬 on 2023/03/07.
//

import Foundation

// MARK: - 8393
//print(solution8393(n: Int(readLine()!)!))

// MARK: - 1929
//let input = readLine()!.split(separator: " ").map { Int(String($0))!}

//solution1929(M: input[0], N: input[1])

// MARK: - 1978
//solution1978(N: Int(readLine()!)!, prob: readLine()!.split(separator: " ").map{
//    Int(String($0))!
//})

// MARK: - 4948
//var n : Int = 1
//while true {
//    n = Int(readLine()!)!
//    if n == 0 {
//        break
//    }
//    solution4948(n: n)
//}

// MARK: - 2609
//let input = readLine()!.split(separator: " ").map{
//    Int(String($0))!
//}
//
//solution2609(n: input[0], m: input[1])

// MARK: - 10828
//solution10828(N: Int(readLine()!)!)

// MARK: - 9012
//solution9012(n: Int(readLine()!)!)

// MARK: - 10773
//solution10773(K: Int(readLine()!)!)

// MARK: - 1935
//solution1935()

// MARK: - 10845
//solution10845()

// MARK: - 11653
//solution11653()

// MARK: - 9020
//solution9020()

// MARK: - 6588
//solution6588()

// MARK: - 1406
//solution1406()

// MARK: - 1182
//solution1182()

// MARK: - 1874
//solution1874()

// MARK: - 17103
//solution17103()

// MARK: - 18258
//solution18258()

// MARK: - 2164
//solution2164()

// MARK: - 10866
//solution10866()

// MARK: - 10870
//solution10870()

// MARK: - 17478
//solution17478()

// MARK: - 1914
//solution1914()

// MARK: - 올바른괄호
//print(solution("()()"))

// MARK: - 10799
//solution10799()

// MARK: - 2493
//solution2493()

// MARK: - 10814
//solution10814()

// MARK: - 1427
//solution1427()

// MARK: - 17298
//solution17298()
//resolution17298()

// MARK: - 2812
//solution2812()

// MARK: - 2947
//solution2947()

// MARK: - 1431
//solution1431()

// MARK: - 2750
//solution2750()

// MARK: - 10989
//solution10989()

// MARK: - 14467
//solution14467()

// MARK: - 5597
//solution5597()

// MARK: - 1244
//solution1244()

// MARK: - 1966
//solution1966()

// MARK: - 11866
//solution11866()

// MARK: - 1475
//solution1475()

// MARK: - 1003
//solution1003()

// MARK: - 1913
//solution1913()

// MARK: - 9461
//solution9461()

// MARK: - 11726
//solution11726()

// MARK: - 16173
//solution16173()

// MARK: - 9095
//solution9095()

// MARK: - 1463
//solution1463()

// MARK: - 2193
//solution2193()

// MARK: - binarySearch
//print(binarySearchRecursive([1,2,6,7,8,10,30,50,56], num: 5))

//print(binarySearch([1,2,6,7,8,10,30,50,56], num: 5))

// MARK: - 10815
//solution10815()

// MARK: - 2805
//solution2805()

// MARK: - 1260
//solution1260()

// MARK: - 2606
//solution2606()

// MARK: - 1325
//solution1325()

// MARK: - 1092
//solution1092()

// MARK: - 11501
//solution11501()

// MARK: - 2872
//solution2872()

// MARK: - 1541
//solution1541()

// MARK: - 10026
//solution10026()

//solution1(["a","b","c"], ["a b","b a", "c a", "a c", "a c", "c a"])
//
////solution1(["m","r","f","n"],["m f","m f", "r m", "r m", "r m", "f m","f r", "n m"])


//solution4(4, [3,6,7,2,1,10,5,9,8,12,11,4])
//solution4(3, [1,2,3,4,5,8,6,7,9,10,11,12])
//solution4(2, [5,8,1,2,9,4,12,11,3,10,6,7])
//solution4(10, [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18])

//print(solution2([[2,3],[4,3],[1,1],[2,1]]))
//solution2([[4,11],[1,12],[8,3],[12,7],[4,2],[7,11],[4,8],[9,6],[10,11],[6,10],[3,5],[11,1],[5,3],[11,9],[3,8]])
//
//print(solution5(10,[0,0,0,0,0,0,0,0,0,0]))

//solution15486()

//solution11058()

//solution10844()

//solution1991()

//solution11724()

//solution10451()

//print(targetNumber([1,1,1,1,1], 3))

//print(solution(5, 31168))

//print(solution("aab", "aba", ["abb", "aba"]))

//solutionE1(4, 5, 5, 10, [[1,1,2],[1,2,3],[2,4,3],[3,1,4],[5,3,3],[5,2,2],[7,4,4],[8,3,3],[10,4,3]])

//solutionE2(3, [25,30,15,20], [[13,21],[18,25],[26,30]])

//print(level1_1([1,2,3,4]))

//print(level2_1("cdcd"))

//print(level2_2(5, [[0,0],[0,-1],[2,-3],[3,-3]]))

//sosu("17")

//print(fatigue(80, [[80,20],[50,40],[30,10]]))

//print(card([[60, 50], [30, 70], [60, 30], [80, 40]]))

//motest([1,2,3,4,5])

//electric(9, [[1,3],[2,3],[3,4],[4,5],[4,6],[4,7],[7,8],[7,9]])

//print(modict("EIO"))

//print(network(3, [[1, 1, 0], [1, 1, 0], [0, 0, 1]]))

//print(travelRoute([["ICN", "SFO"], ["ICN", "ATL"], ["SFO", "ATL"], ["ATL", "ICN"], ["ATL","SFO"]]))

//print(joystick("JEROEN"))

//print(clothes([["yellow_hat", "headgear"], ["blue_sunglasses", "eyewear"], ["green_turban", "headgear"]]))

//print(bigNum([6,10,2]))

//bingo()

//stroll()

//friendPrice()

//solution1182()

//solution1325()

//solution_2805()

//solution16236()

//solution17144()

//solution7579()

//solution2589()

//solution4485()

//solution2293()

//solution3109()

//solution17626()

//solution11000()

//solution2482()

//solution1194()

//solution9470()

//solution1922()

//solution12865()

//solution1365()

//solution2133()

//solution1976()

//solution15683()

//solution1918()

//solution17836()

//solution16234()

//solution1197()

//solution17472()

//solution1927()

//solution1753()

//solution5719()

//solution1939()

//solution1005()

//solution1850()

//solution11286()

//solution1931()

//solution7576()

//solution14003()

//solution11723()

//solution1074()

//solution14940()

//solution1697()

//solution15650()

//solution11725()

//solution9251()

//solution9663()

//solution11053()

//solution15654()

//solution13549()

//solution11444()

//solution10830()

//solution15663()

//solution2206()

//solution1629()

//solution1967()

//solution1167()

//solution11404()

//solution11049()

//solution11660()

//solution1806()

//solution18258()

//solution9252()

//solution12015()

//solution2252()

//solution2467()

//solution2473()

//solution10942()

//solution2623()

//solution7453()

//solution9466()

//solution1202()

//solution1238()

//solution1865()

//solution9465()

//solution1932()

//solution1149()

//solution13460()

func solution13460() {
    let fileIO = FileIO()

    let n = fileIO.readInt()
    let m = fileIO.readInt()

    var map: [[String]] = []
    var visitedRed: [[Int]] = Array(repeating: Array(repeating: -1, count: m), count: n)
    var visitedBlue: [[Int]] = Array(repeating: Array(repeating: -1, count: m), count: n)
    var visitedArray: [[String]] = Array(repeating: Array(repeating: "", count: m), count: n)

    var blue: (x: Int, y: Int) = (0, 0)
    var red: (x: Int, y: Int) = (0, 0)
    var hole: (x: Int, y: Int) = (0, 0)

    for x in 0..<n {
        var array: [String] = []
        for y in 0..<m {
            let value = fileIO.readString()
            array.append(value)
            switch value {
            case "B":
                blue = (x, y)
            case "R":
                red = (x, y)
            case "O":
                hole = (x, y)
            default:
                continue
            }
        }
        map.append(array)
    }

    var queue = Queue(elements: [[red, blue]])
    visitedRed[red.x][red.y] = 0
    visitedBlue[blue.x][blue.y] = 0

    while !queue.isEmpty {
        guard let element = queue.removeFirst() else { return }

        var redBead = element[0]
        var blueBead = element[1]

        var tryCount = visitedRed[redBead.x][redBead.y] + 1

        // 위로 기울이기
        if redBead.y == blueBead.y {
            // 같은 열에 있을 경우
            if redBead.x < blueBead.x {
                // 빨간 구슬이 위에 있을 경우
                while true {
                    redBead.x += 1

                    if map[redBead.x][redBead.y] == "#" {
                        break
                    } else {
                        visitedRed[redBead.x][redBead.y] = visitedRed[redBead.x][redBead.y] == -1 ? tryCount: min(visitedRed[redBead.x][redBead.y], tryCount)
                    }
                }
                redBead.x -= 1
                

                if visitedRed[redBead.x][redBead.y] == tryCount {
                    queue.append([redBead, blueBead])
                }
            }
        }
    }

    struct Queue {
        var elements: [[(Int, Int)]] = []
        var head: Int = 0
        var isEmpty: Bool { elements.count <= head }

        mutating func append(_ element: [(Int, Int)]) {
            elements.append(element)
        }

        mutating func removeFirst() -> [(x: Int, y: Int)]? {
            guard !isEmpty else { return nil }
            let value = elements[head]
            head += 1

            return value
        }

    }
}

//solution1106()

//solution1916()

//solution11779()

//solution17070()

//solution1647()

//solution2143()

//solution2342()
//
//func solution2342() {
//    let fileIO = FileIO()
//
//    var dp: [[Position]] = [[Position(left: .중, right: .중, value: 0), Position(left: .중, right: .중, value: 0)]]
//    var index: Int = 0
//    while true {
//        let num = fileIO.readInt()
//        guard let newPoint = Point(rawValue: num) else { break }
//        let newLeftPosition = min(dp[index][0].move(to: newPoint, by: .left),
//                              dp[index][1].move(to: newPoint, by: .left))
//        let newRightPosition = min(dp[index][0].move(to: newPoint, by: .right),
//                              dp[index][1].move(to: newPoint, by: .right))
//        dp.append([newLeftPosition, newRightPosition])
//        index += 1
//    }
//
//    print(min(dp[index][0], dp[index][1]).value)
//
//    struct Position {
//        let left: Point
//        let right: Point
//        let value: Int
//
//        func move(to point: Point, by direction: Direction) -> Position {
//            switch direction {
//            case .left:
//                return Position(left: point, right: right, value: value + left.move(to: point))
//            case .right:
//                return Position(left: left, right: point, value: value + right.move(to: point))
//            }
//        }
//
//        enum Direction {
//            case left
//            case right
//        }
//    }
//    enum Point: Int {
//        case 상 = 1
//        case 좌
//        case 하
//        case 우
//        case 중
//
//        func move(to point: Point) -> Int {
//            switch self {
//            case .중:
//                return 2
//            default:
//                if self == point { return 1 }
//                else { return abs(self.rawValue - point.rawValue) == 2 ? 4: 3 }
//            }
//        }
//    }
//
//    func min(_ first: Position, _ second: Position) -> Position {
//        return first.value > second.value ? second: first
//    }
//}

//solution27172()

//solution2568()

//solution16724()

//solution1766()

//solution12100()

//solution2239()

//solution15686()

//solution1644()

//solution27924()

//solution9084()

//solution2655()

//solution1799()

//solution1717()

//solution17835()

//solution1520()

//solution27945()

//solution1600()

//solution16926()
//
//func solution16926() {
//    let fileIO = FileIO()
//
//    let n = fileIO.readInt()
//    let m = fileIO.readInt()
//    let r = fileIO.readInt()
//
//    var array: [[Int]] = []
//
//    for _ in 0..<n {
//        var elements: [Int] = []
//        for _ in 0..<m {
//            elements.append(fileIO.readInt())
//        }
//        array.append(elements)
//    }
//
//    let moveX = [1, 0, -1, 0]
//    let moveY = [0, 1, 0, -1]
//
//    let visitedMock: [[Bool]] = Array(repeating: Array(repeating: false, count: m), count: n)
//    for _ in 0..<r {
//        var visited = visitedMock
//
//        
//
//    }
//}

//solution18809()

//solution1107()

//solution11559()

//solution17281()

//solution2617()

//solution2786()

//solution7511()

//solution3055()

//solution3020()

//solution17182()

//solution2580()

//solution10282()

//solution1477()

//solution4386()

//solution2981()

//solution1915()

//solution2169()

//solution2661()

//solution1630()

//solution2831()

//solution20366()

//solution15961()

solution15685()
