# 컨텍스트 스위칭(Context Switching)과 PCB/TCB
컨텍스트 스위칭(Context Switching)은 CPU가 한 프로세스(정확히는 스레드)에서 다른 프로세스/스레드로 전환할 때 발생하는 일련의 과정을 말한다. CPU **코어 하나는 한 순간에 하나의 실행 흐름만 수행**할 수 있지만, 운영체제는 동시성(Concurrency)을 통해 여러 작업을 매우 빠르게 번갈아 실행하여 사용자에게 동시에 실행되는 것처럼 보이게 만든다. 이때 작업 전환을 위해 컨텍스트 스위칭이 필요하다.

컨텍스트 스위칭은 실행 중인 프로세스/스레드가 중단될 때 그 상태(Context: 레지스터, 프로그램 카운터 등)를 저장하고, 다음 실행할 프로세스/스레드의 상태를 복구하여 실행을 이어가는 과정이다. 다음에 실행할 대상을 **스케줄러(Scheduler)** 가 결정하며, 실제로 상태 저장/복구를 수행해 CPU 실행 흐름을 전환하는 작업은 **디스패처(Dispatcher)** 가 담당한다.

---

## PCB (Process Control Block)

PCB(Process Control Block)는 운영체제가 프로세스를 관리하기 위해 유지하는 **커널 자료구조**로, 해당 프로세스의 실행 상태와 자원 정보를 포함한다.

운영체제는 컨텍스트 스위칭이 발생할 때 현재 실행 중인 프로세스의 상태(레지스터, PC 등)를 PCB에 저장하고, 다음에 실행할 프로세스의 PCB에서 상태를 복원하여 이전 실행 흐름을 이어갈 수 있도록 한다. 즉, PCB는 프로세스의 스케줄링, 실행 상태 관리, 자원 관리 등을 위해 필요한 핵심 정보를 담고 있다.

따라서 운영체제는 PCB에 담긴 프로세스 고유 정보를 바탕으로 프로세스를 관리하며, 프로세스의 실행 상태를 파악하고 CPU 자원 배분을 위한 우선순위 및 스케줄링 정보를 참고하여 실행 대상을 결정한다. 또한 프로세스가 I/O나 동기화 작업으로 인해 대기 상태로 전환되는 등의 상태 변화를 관리한다.

> **프로세스 스케줄링(Process Scheduling)**이란, 운영체제가 여러 프로세스(정확히는 스레드) 중에서
> 
> 
> **어떤 작업을 언제 CPU에 할당할지 결정하는 과정**이다.
> 
> CPU는 한 순간에 하나의 작업(코어 기준)만 실행할 수 있기 때문에, 운영체제는 준비(Ready) 상태의 작업들 중 하나를 선택하여 실행하고, 필요에 따라 실행 중인 작업을 중단시키고 다른 작업으로 전환(Context Switching)한다.
> 

운영체제에 따라 PCB에 포함되는 항목은 다를 수 있지만, 일반적으로 PCB에는 다음과 같은 정보가 포함된다.

![image.png](attachment:eb82a4f8-fd78-4b1d-a486-44e8902597cd:image.png)

- 프로세스 상태 (Process state) : 프로세스의 각 상태 - 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated) 를 저장
- 프로세스 아이디 (Process number, Process ID, PID) : 프로세스 식별자를 지정하는 고유 ID
- 프로그램 카운터 (Program counter) : 해당 프로세스 내, 다음에 실행할 명령어의 주소
- 레지스터 (Registers) : 레지스터는 컴퓨터 아키텍처에 따라 종류와 개수가 다양하다.
    
    예를 들어 **누산기(accumulator), 인덱스 레지스터(index register), 스택 포인터(stack pointer), 범용 레지스터(general-purpose registers)** 등이 있고, **조건 코드(condition-code)** 정보도 포함된다.
    
    또한 프로그램 카운터와 함께 이러한 CPU 상태 정보는 **인터럽트(interrupt)가 발생했을 때 반드시 저장되어야** 한다. 그래야 인터럽트 처리 후 프로세스가 다시 정상적으로 이어서 실행될 수 있다.
    
- 메모리 관리 정보(Memory-management information, Memory Limits) : 운영 체제에서 사용하는 메모리 관리 시스템에 대한 정보
    
    메모리 시스템에 따라 포함 정보가 달라질 수 있다.
    
    예시:
    
    - base/limit 레지스터 값
    - 페이지 테이블(page table)
    - 세그먼트 테이블(segment table)
- 열린 파일 목록 (List of open file) : 현재 프로세스가 열어둔 파일 정보

### PCB 관리 방식

운형체제에서 PCB는 연결 리스트(Linked List) 형태로 구현되어 관리된다. 프로세스의 생성, 종료가 빈번해 메모리 할당 및 해제가 유연해야 하고, CPU 스케줄링을 위해 PCB들을 효율적으로 연결하고 관리하기 용이 하기 때문이다. 

프로세스가 생성되면 해당 PCB가 생성되고, 해당 PCB는 PCB List Head에 붙게 된다. 또한 프로세스가 종료 되면 PCB도 제거된다.

## Context Switcing 과정

![Diagram showing CPU switch from process to process.](attachment:0c668f5f-bc61-4654-971a-b33c2beca38e:image.png)

Diagram showing CPU switch from process to process.

위 다이어그램은 프로세스 간 컨텍스트 스위칭을 보여주고 있다.

1. CPU가 프로세스 P0를 실행(executing)하던 중 인터럽트(Interrupt) 또는 시스템 콜(System Call)이 발생한다.
2. CPU 제어권이 운영체제(OS, 커널)로 넘어가고(CPU가 idle상태가 됨), 운영체제는 현재 실행 중이던 프로세스 P0의 상태(Context)를 PCB0에 저장(save)한다.
3. 이후 운영체제는 PCB1에 저장되어 있던 프로세스 P1의 실행 상태(Context)를 복원(reload)하여 CPU에 세팅한다.
4. 세팅이 끝나면 운영체제는 유저 모드로 복귀하고, 프로세스 P1이 실행(executing)된다.
5. 이후 다시 인터럽트 또는 시스템 콜이 발생하면 같은 방식으로 상태를 저장/복원하면서 실행 프로세스가 전환된다.

이때 컨텍스트 스위칭 구간은 사용자 프로그램을 실행하지 않고 커널이 상태 저장/복원을 수행하는 시간이므로 오버헤드가 발생한다.

---

## Context Switcing Overhead

컨텍스트 스위칭(Context Switching)은 사용자에게 빠른 반응성과 동시성(Concurrency)을 제공하지만, 실행 흐름을 전환하는 과정에서 현재 실행 중인 프로세스/스레드의 상태(Context)를 저장하고 다음 작업의 상태를 복원해야 하므로 일정한 비용(Overhead)이 발생한다.

다이어그램을 보면 프로세스 P0의 실행이 중단된 후, 프로세스 P1이 즉시 실행되는 것이 아니라 **운영체제(OS, 커널)가 상태 저장/복원 작업을 수행한 뒤** 실행되는 것을 확인할 수 있다. 이때 **사용자 프로그램은 실행되지 않고 커널 코드만 실행되며**, 이 구간이 바로 컨텍스트 스위칭 오버헤드에 해당한다.

컨텍스트 스위칭 오버헤드를 이르키는 대표적인 원인들은 아래와 같다.

- **Context 저장 및 복원 비용**
    - 레지스터, 프로그램 카운터(PC), 스택 포인터 등의 상태를 저장/복원
    - 프로세스라면 주소공간 관련 정보까지 더 많은 상태를 전환
- **CPU 캐시 및 TLB 관련 비용**
    - 실행 대상이 바뀌면 기존 캐시/번역 정보가 충분히 재사용되지 못해 캐시 미스가 증가할 수 있음
- **스케줄링 비용**
    - 스케줄러가 ready queue에서 다음 실행 대상을 선택하는 비용이 발생

프로세스간 컨텍스트 스위칭 뿐만 아니라 스레드간 컨텍스트 스위칭도 마찬가지다. 멀티 스레딩은 동시 작업 처리에 유리하지만, 스레드 수가 과도하게 많아지면 컨텍스트 스위칭이 빈번해져 오히려 성능이 떨어질 수 있다. 따라서 “스레드를 많이 만들수록 무조건 성능이 좋아진다”는 것은 정확하지 않으며, 작업 특성과 병목(I/O vs CPU), 스레드 수에 대한 적절한 설계가 필요하다.

---

## TCB (Thread Control Block)

스레드 역시 PCB처럼 운영체제가 각 스레드를 관리하기 위해 유지하는 자료구조가 존재하며 이를 **TCB(Thread Control Block)** 라고 한다. TCB에는 스레드의 실행 상태를 복원하고 스케줄링하기 위해 필요한 정보들이 저장된다.

- 스레드 상태(state)
- 스레드 ID(TID)
- 레지스터/프로그램 카운터(PC) 등 실행 컨텍스트
- 스레드 우선순위(priority)
- 스케줄링 정보(큐 포인터 등)

TCB 또한 스레드가 생성될 때 운영체제에 의해 생성되며, 스레드가 실행을 마치고 소멸될 때 함께 제거된다.

또한 뮤텍스(mutex), 세마포어(semaphore) 같은 동기화 기법을 사용할 경우 스레드는 락을 기다리며 대기(block) 상태가 될 수 있는데, 이때 운영체제는 해당 스레드의 TCB를 기반으로 상태를 변경하고(wait queue에 연결하는 등) 스케줄링을 수행한다.

> 뮤텍스(mutex): 임계 구역에 1개의 스레드만 들어갈 수 있는 동기화 기법.
세마포어(semaphore): 임계 구역에 여러 스레드가 들어갈 수 있고, counter를 통해 허용 가능한 스레드를 제한하는 기법.
> 

뮤텍스와 세마포어에 대해서는 이 후에 더 자세히 다루겠다.

---

## 컨텍스트 스위칭 (프로세스 vs 스레드)

멀티 태스킹 환경에서 여러 프로세스 또는 스레드를 동시에 실행하기 위해서는 컨텍스트 스위칭 과정이 무조건 필요하다. 이 두 과정은 몇 가지 차이점이 존재한다.

### 1. TCB가 PCB보다 가볍다

같은 프로세스 내의 스레드들은 코드(text), 데이터(data), 힙(heap) 영역을 공유한다. 따라서 스레드 컨텍스트 스위칭은 보통 스레드마다 독립적인 스택(stack)과 레지스터/PC/SP 등의 실행 컨텍스트만 저장 및 복원하면 된다. 이 때문에 스레드 간 컨텍스트 스위칭은 프로세스 간 컨텍스트 스위칭보다 일반적으로 비용이 낮다.

반면 프로세스 컨텍스트 스위칭은 실행 스레드 상태뿐 아니라 주소 공간 전환이 동반되며(페이지 테이블 등), 운영체제/하드웨어 수준에서 더 많은 상태 변경이 필요하므로 오버헤드가 커질 수 있다.

### 2. 캐시 메모리 초기화 여부

> CPU 캐시는 CPU와 메인 메모리 사이에서 최근 사용한 명령어/데이터를 저장해두었다가 재사용할 때 접근 속도를 높여주는 장치다.
> 

프로세스 컨텍스트 스위칭이 발생하면 실행 대상이 바뀌면서 새로운 명령어와 데이터가 로드되고, 결과적으로 기존 캐시 데이터는 캐시 미스(cache miss)가 증가할 수 있다. 또한 프로세스 전환은 서로 다른 주소 공간을 사용하는 경우가 많기 때문에 페이지 테이블 전환 및 TLB(주소 변환 캐시) 효율 저하 등의 비용이 함께 발생한다.

스레드 컨텍스트 스위칭은 같은 프로세스의 주소 공간을 공유하는 경우가 많아 주소 공간 전환 비용이 상대적으로 적으며, 캐시 데이터도 일부 재사용될 가능성이 높다. 다만 스레드가 다른 CPU 코어로 이동하는 경우에는 캐시 지역성이 깨지면서 성능 저하가 발생할 수 있다.

### 3. 자원 동기화 문제

스레드는 같은 프로세스의 힙(heap) 영역 등을 공유할 수 있으므로, 여러 스레드가 동시에 동일한 데이터에 접근할 경우 경쟁 상태(Race Condition)가 발생할 수 있다. 예를 들어 두 스레드가 동시에 같은 변수를 수정하면 결과 값이 의도와 다르게 저장될 수 있다. 이를 방지하기 위해 뮤텍스(mutex), 세마포어(semaphore) 같은 동기화 기법이 필요하다.

프로세스는 기본적으로 서로 독립된 주소 공간을 갖지만, IPC(shared memory, file 등)를 통해 자원을 공유하는 경우에는 프로세스 간에도 동일하게 경쟁 상태가 발생할 수 있다. 따라서 공유 자원을 사용하는 모든 상황에서는 적절한 동기화 메커니즘이 필요하다.

> 일반적으로 프로세스 컨텍스트 스위칭은 주소 공간 전환이 동반되므로, 스레드 컨텍스트 스위칭보다 비용이 더 크다.
> 

사진 출처 - operating system concepts essentials 2nd edition

---

## iOS 관점에서 알면 좋을 것들

이전 글(멀티 프로세스 vs 멀티 스레드)에서도 다뤘지만, iOS 개발자라면 운영체제 관점에서 추가로 알아두면 좋은 내용들이 있다.

iOS 앱 개발에서는 서드파티 앱이 임의로 여러 프로세스를 생성하는 경우가 거의 없기 때문에, 대부분의 성능 최적화와 동시성 처리는 **멀티 프로세스보다는 멀티 스레드 기반**으로 이루어진다. 즉, 앱 내부에서 여러 작업을 동시에 처리하기 위해 메인 스레드 외의 백그라운드 스레드를 활용하는 방식이 일반적이다.

이 과정에서 iOS에서도 당연히 **스레드 컨텍스트 스위칭(Thread Context Switching)** 이 발생하며, 컨텍스트 스위칭 과정에서 상태 저장/복원 비용이 발생하기 때문에 **컨텍스트 스위칭 오버헤드(Context Switching Overhead)** 또한 존재한다.

### 1. 모바일 OS는 “성능”뿐 아니라 “배터리”가 중요하다

컨텍스트 스위칭은 단순히 CPU 시간을 소모하는 것뿐 아니라, 결과적으로

- 더 많은 CPU 사용량
- 캐시 효율 저하
- 스케줄링 횟수 증가

로 이어질 수 있다. 특히 iOS는 데스크탑 OS처럼 항상 전원에 연결된 환경이 아니기 때문에, 성능 최적화는 곧 **배터리 효율**과 직결된다.

즉, 스레드를 무분별하게 많이 생성하면 “성능 향상”이 아니라 오히려 **발열 상승 → 배터리 소모 증가 → 성능 제한(스로틀링)**과 같은 결과로 이어질 수 있다.

### 2. iOS UI 규칙: 메인 스레드는 절대 막히면 안 된다

iOS는 UI 업데이트가 반드시 **메인 스레드(Main Thread)** 에서 수행되어야 한다. UIKit/SwiftUI에서 화면 렌더링과 사용자 입력 이벤트 처리는 메인 스레드 기반으로 동작하기 때문이다.

따라서 네트워크 요청, 파일 I/O, 이미지 디코딩, JSON 파싱처럼 오래 걸릴 수 있는 작업을 메인 스레드에서 수행하면 앱 화면이 멈추거나 끊기는 현상이 발생한다.

이러한 문제는 결국 운영체제 관점에서 보면,

- “메인 스레드가 CPU를 점유한 채 오래 실행됨”
- “스케줄링과 컨텍스트 스위칭이 정상적으로 이루어져도 UI 처리가 밀림”
- “사용자 입장에서는 앱이 버벅이는 것처럼 보임”

이라는 흐름으로 설명할 수 있다.

### 3. iOS에서는 Thread를 직접 다루기보다 “작업 단위”로 설계한다

iOS에서는 스레드를 직접 생성하여 관리하기보다는 일반적으로

- GCD(DispatchQueue)
- OperationQueue
- Swift Concurrency(async/await, Task)

와 같은 고수준 API를 사용한다.

이들은 내부적으로 **스레드 풀(thread pool)** 등을 통해 불필요한 스레드 생성을 줄이고, 운영체제 스케줄러가 효율적으로 작업을 수행할 수 있도록 설계되어 있다.

즉, iOS 멀티스레딩에서 중요한 것은 “스레드 개수”가 아니라 어떤 작업을 어떤 우선순위로, 어떻게 분리해서 처리할 것인가이다.

### 4. QoS는 운영체제 스케줄러에게 주는 힌트이다

GCD나 Swift Concurrency에서 설정할 수 있는 QoS(Quality of Service)를 통해 작업 우선순위를 설정할 수 있다. QoS는 운영체제 스케줄러에게 “이 작업이 사용자 경험에 얼마나 중요한가?” 를 알려주는 힌트 역할을 한다.

- `.userInteractive` : UI 즉시 반응 필요
- `.userInitiated` : 곧 사용될 작업(로딩 등)
- `.utility` : 오래 걸리지만 진행돼야 하는 작업
- `.background` : 사용자에게 보이지 않는 작업

예를 들어 UI 반응에 중요한 작업은 높은 우선순위를 가져야 하고, 사용자에게 보이지 않는 작업은 낮은 우선순위로 수행되어야 한다. 이를 적절히 설정하면 메인 스레드의 부하를 줄이고 전체 앱 반응성을 개선할 수 있다.

### 마무리

iOS 개발자는 PCB나 TCB 같은 자료구조를 직접 다루지는 않지만, 앱이 여러 작업을 수행하는 과정에서 운영체제는 스레드 단위로 스케줄링을 수행하며, 그 과정에서 컨텍스트 스위칭 오버헤드가 발생한다.

따라서 운영체제의 컨텍스트 스위칭과 스케줄링 개념을 이해하면, iOS 앱 개발에서도

- UI 끊김(stutter) 원인 분석
- 비동기 처리 설계
- 스레드 과다 생성 방지
- 배터리/발열 관점 최적화

등을 더 논리적으로 접근할 수 있게 된다.
